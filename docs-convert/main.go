package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

func convertFile(srcPath, dstPath string) error {
	src, err := os.Open(srcPath)
	if err != nil {
		return err
	}
	defer src.Close()

	dst, err := os.Create(dstPath)
	if err != nil {
		return err
	}
	defer dst.Close()

	scanner := bufio.NewScanner(src)
	writer := bufio.NewWriter(dst)
	defer writer.Flush()

	var lines []string
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		return err
	}

	// Trim excessive trailing blank lines (keep at most 1)
	for len(lines) > 0 && strings.TrimSpace(lines[len(lines)-1]) == "" {
		lines = lines[:len(lines)-1]
	}

	// Check if this is the v1alpha1/config file or cli file
	isConfigFile := strings.Contains(dstPath, "v1alpha1/config.mdx") || strings.Contains(dstPath, "v1alpha1\\config.mdx")
	isCliFile := strings.HasSuffix(dstPath, "/cli.mdx") || strings.HasSuffix(dstPath, "\\cli.mdx")

	// Process lines
	i := 0
	inFrontmatter := false
	for i < len(lines) {
		line := lines[i]

		// Track frontmatter boundaries
		if line == "---" {
			if !inFrontmatter {
				inFrontmatter = true
				fmt.Fprintln(writer, line)
				i++
				continue
			} else {
				// End of frontmatter
				inFrontmatter = false
				fmt.Fprintln(writer, line)
				// Add auto-generated comment after frontmatter
				fmt.Fprintln(writer, "")
				fmt.Fprintln(writer, "{/*")
				fmt.Fprintln(writer, "This file is automatically generated from source documentation.")
				fmt.Fprintln(writer, "Do not edit manually. For more information, see https://github.com/siderolabs/docs")
				fmt.Fprintln(writer, "*/}")
				i++
				continue
			}
		}

		// Handle title in frontmatter for config and cli files
		if inFrontmatter && strings.HasPrefix(line, "title:") {
			if isConfigFile {
				fmt.Fprintln(writer, "title: MachineConfig")
				i++
				continue
			}
			if isCliFile {
				fmt.Fprintln(writer, "title: talosctl")
				i++
				continue
			}
		}

		// Handle multi-line description in frontmatter
		if inFrontmatter && strings.HasPrefix(line, "description: |") {
			// Collect all indented lines that follow
			descriptionParts := []string{}
			i++
			for i < len(lines) && len(lines[i]) > 0 && (lines[i][0] == ' ' || lines[i][0] == '\t') {
				// Remove leading whitespace and add to parts
				descriptionParts = append(descriptionParts, strings.TrimSpace(lines[i]))
				i++
			}
			// Join all parts into a single line
			singleLineDescription := strings.Join(descriptionParts, " ")
			// Escape single quotes in the description
			singleLineDescription = strings.Replace(singleLineDescription, "'", "''", -1)
			// Quote the description with single quotes to handle special characters
			fmt.Fprintf(writer, "description: '%s'\n", singleLineDescription)
			continue
		}

		// Check if this line starts an Accordion with inline code
		if strings.Contains(line, "<details><summary>") {
			// Find the end of the Accordion (</details>)
			endLine := i
			for endLine < len(lines) && !strings.Contains(lines[endLine], "</details>") {
				endLine++
			}

			if endLine < len(lines) {
				// Collect all lines in the Accordion
				accordionLines := append([]string{line}, lines[i+1:endLine+1]...)
				fullContent := strings.Join(accordionLines, "\n")

				// Replace tags
				fullContent = strings.Replace(fullContent, "<details><summary>", "<Accordion title=\"", 1)
				fullContent = strings.Replace(fullContent, "</summary>", "\">", 1)
				fullContent = strings.Replace(fullContent, "</details>", "</Accordion>", 1)

				// Convert Hugo shortcodes to markdown code blocks
				fullContent = strings.Replace(fullContent, "{{< highlight yaml >}}", "```yaml", -1)
				fullContent = strings.Replace(fullContent, "{{< /highlight >}}", "```", -1)

				// Convert <br> to <br /> for MDX compatibility
				fullContent = strings.Replace(fullContent, "<br>", "<br />", -1)

				fmt.Fprintln(writer, fullContent)
				i = endLine + 1
				continue
			}
		}

		// Check if this line starts a markdown table (must be outside frontmatter)
		if !inFrontmatter && detectTableStart(line) {
			// Look ahead to see if next line is separator
			if i+1 < len(lines) && isTableSeparator(lines[i+1]) {
				// Convert table to HTML
				tableHTML, endIdx := convertTableToHTML(lines, i)
				if tableHTML != "" {
					fmt.Fprintln(writer, tableHTML)
					i = endIdx
					continue
				}
			}
		}

		// Handle regular lines - convert Hugo shortcodes to code blocks
		line = strings.Replace(line, "{{< highlight yaml >}}", "```yaml", -1)
		line = strings.Replace(line, "{{< /highlight >}}", "```", -1)

		// Convert <br> to <br /> for MDX compatibility
		line = strings.Replace(line, "<br>", "<br />", -1)

		// Skip markdownlint-disable comments
		if strings.Contains(line, "<!-- markdownlint-disable -->") {
			i++
			continue
		}

		// Remove {#anchor-id} from headings (MDX doesn't support this syntax)
		if strings.HasPrefix(strings.TrimSpace(line), "#") && strings.Contains(line, "{#") {
			start := strings.Index(line, "{#")
			end := strings.Index(line, "}")
			if end > start && end != -1 {
				line = strings.TrimSpace(line[:start] + line[end+1:])
			}
		}

		// Fix anchor links - remove page name prefix (e.g., #Config.machine -> #machine)
		line = fixAnchorLinks(line)

		// Escape placeholder-like angle brackets (e.g., <src-path>, <dest-path>)
		// but preserve actual HTML tags (a, br, Accordion)
		// Simple heuristic: if it contains a hyphen or underscore, it's likely a placeholder
		line = escapeAngleBracketPlaceholders(line)

		fmt.Fprintln(writer, line)
		i++
	}

	return nil
}

func fixAnchorLinks(line string) string {
	// Find and fix all href="#..." patterns
	result := ""
	for {
		// Find next href="#
		start := strings.Index(line, "href=\"#")
		if start == -1 {
			result += line
			break
		}

		// Add everything before the href including 'href="#'
		result += line[:start+7] // include 'href="#'
		line = line[start+7:]    // skip past 'href="#'

		// Find the closing quote
		end := strings.Index(line, "\"")
		if end == -1 {
			// Malformed, just add rest and break
			result += line
			break
		}

		// Extract the anchor value
		anchor := line[:end]

		// Remove trailing dot if present
		anchor = strings.TrimSuffix(anchor, ".")

		// Fix the anchor by taking the last segment
		if strings.Contains(anchor, ".") {
			// Find the last dot and take everything after it
			lastDot := strings.LastIndex(anchor, ".")
			if lastDot != -1 {
				anchor = anchor[lastDot+1:]
			}
		}

		// Convert to lowercase
		anchor = strings.ToLower(anchor)

		// URL-encode square brackets
		anchor = strings.Replace(anchor, "[", "%5B", -1)
		anchor = strings.Replace(anchor, "]", "%5D", -1)

		result += anchor + "\""
		line = line[end+1:]
	}

	return result
}

func escapeAngleBracketPlaceholders(line string) string {
	result := ""
	i := 0
	for i < len(line) {
		// Check for HTML comment pattern <!--
		if i+3 < len(line) && line[i:i+4] == "<!--" {
			// Find the closing -->
			end := strings.Index(line[i:], "-->")
			if end != -1 {
				// Extract comment content and convert to MDX format
				commentContent := line[i+4 : i+end] // Extract text between <!-- and -->
				result += "{/*" + commentContent + "*/}"
				i = i + end + 3 // +3 for "-->"
				continue
			}
		}

		// Check for Hugo shortcode start pattern {{<
		if i+2 < len(line) && line[i:i+3] == "{{<" {
			// Find the closing >}}
			end := strings.Index(line[i:], ">}}")
			if end != -1 {
				// Skip the entire Hugo shortcode
				end = i + end + 3 // +3 for ">}}"
				result += line[i:end]
				i = end
				continue
			}
		}

		if line[i] == '<' {
			// Find the closing >
			end := i + 1
			for end < len(line) && line[end] != '>' {
				end++
			}
			if end < len(line) {
				// Extract the content between < and >
				content := line[i+1 : end]
				// Check if it's likely a placeholder or text that should not be parsed as HTML
				// Known HTML tags we want to preserve: a, br, p, Accordion, details, summary, pre, code, td, th, tr, table, thead, tbody and their closing tags
				isKnownTag := strings.HasPrefix(content, "a ") ||
					content == "a" ||
					strings.HasPrefix(content, "br") ||
					content == "p" ||
					strings.HasPrefix(content, "p ") ||
					strings.HasPrefix(content, "Accordion") ||
					strings.HasPrefix(content, "details") ||
					strings.HasPrefix(content, "summary") ||
					strings.HasPrefix(content, "pre") ||
					content == "pre" ||
					strings.HasPrefix(content, "code") ||
					content == "code" ||
					strings.HasPrefix(content, "td") ||
					content == "td" ||
					strings.HasPrefix(content, "th") ||
					content == "th" ||
					strings.HasPrefix(content, "tr") ||
					content == "tr" ||
					strings.HasPrefix(content, "table") ||
					strings.HasPrefix(content, "thead") ||
					strings.HasPrefix(content, "tbody") ||
					content == "/a" ||
					content == "/br" ||
					content == "/p" ||
					content == "/Accordion" ||
					content == "/details" ||
					content == "/summary" ||
					content == "/pre" ||
					content == "/code" ||
					content == "/td" ||
					content == "/th" ||
					content == "/tr" ||
					content == "/table" ||
					content == "/thead" ||
					content == "/tbody"

				// If it's not a known HTML tag, escape using JSX expressions
				if !isKnownTag {
					result += `{"<"}` + content + `{">"}`
					i = end + 1
					continue
				} else {
					// For known HTML tags, copy the entire tag at once
					result += line[i : end+1]
					i = end + 1
					continue
				}
			}
		}
		result += string(line[i])
		i++
	}
	return result
}

// detectTableStart checks if a line is the start of a markdown table
func detectTableStart(line string) bool {
	trimmed := strings.TrimSpace(line)
	return strings.Contains(trimmed, "|") && !strings.HasPrefix(trimmed, "{{< highlight")
}

// isTableSeparator checks if a line is the separator row (e.g., |---|---|)
func isTableSeparator(line string) bool {
	trimmed := strings.TrimSpace(line)
	if !strings.Contains(trimmed, "|") {
		return false
	}
	// Remove pipes and trim
	content := strings.Trim(trimmed, "|")
	parts := strings.Split(content, "|")
	for _, part := range parts {
		part = strings.TrimSpace(part)
		// Check if it's composed of hyphens and optional colons for alignment
		if len(part) == 0 {
			return false
		}
		for _, ch := range part {
			if ch != '-' && ch != ':' {
				return false
			}
		}
	}
	return true
}

// parseTableAlignment extracts column alignment from separator row
func parseTableAlignment(line string) []string {
	trimmed := strings.TrimSpace(line)
	content := strings.Trim(trimmed, "|")
	parts := strings.Split(content, "|")
	alignments := make([]string, len(parts))

	for i, part := range parts {
		part = strings.TrimSpace(part)
		hasLeft := strings.HasPrefix(part, ":")
		hasRight := strings.HasSuffix(part, ":")

		if hasLeft && hasRight {
			alignments[i] = "center"
		} else if hasRight {
			alignments[i] = "right"
		} else if hasLeft {
			alignments[i] = "left"
		} else {
			alignments[i] = ""
		}
	}
	return alignments
}

// parseTableRow extracts cells from a table row (handles multi-line cells)
func parseTableRow(lines []string, startIdx int) ([]string, int) {
	// Collect lines until we find the next row or end of table
	rowLines := []string{lines[startIdx]}
	currentIdx := startIdx + 1
	emptyLineCount := 0

	// Keep adding lines until we find another row (starts with |) or reach end
	for currentIdx < len(lines) {
		line := lines[currentIdx]
		trimmed := strings.TrimSpace(line)

		// If line starts with |, it's the next row
		if strings.HasPrefix(trimmed, "|") {
			break
		}

		// Count consecutive empty lines - only break after 2+ empty lines
		// (single empty lines can be part of code blocks in table cells)
		if trimmed == "" {
			emptyLineCount++
			if emptyLineCount >= 2 {
				break
			}
		} else {
			emptyLineCount = 0
		}

		// Add to current row
		rowLines = append(rowLines, line)
		currentIdx++
	}

	// Join all lines and parse
	fullRow := strings.Join(rowLines, "\n")
	trimmed := strings.TrimSpace(fullRow)
	content := strings.Trim(trimmed, "|")

	// Split by | but be smarter about it - handle | inside <details> tags
	cells := make([]string, 0)
	currentCell := ""
	inDetails := false
	i := 0

	for i < len(content) {
		// Check for <details> opening
		if i+8 <= len(content) && content[i:i+8] == "<details" {
			inDetails = true
		}
		// Check for </details> closing
		if i+10 <= len(content) && content[i:i+10] == "</details>" {
			currentCell += "</details>"
			i += 10
			inDetails = false
			continue
		}

		// If we hit a | and we're not inside <details>, it's a cell separator
		if content[i] == '|' && !inDetails {
			cells = append(cells, strings.TrimSpace(currentCell))
			currentCell = ""
			i++
			continue
		}

		currentCell += string(content[i])
		i++
	}

	// Add the last cell
	if len(currentCell) > 0 || len(cells) > 0 {
		cells = append(cells, strings.TrimSpace(currentCell))
	}

	return cells, currentIdx
}

// processCellContent applies transformations to cell content
func processCellContent(content string) string {
	// Remove <details> blocks entirely
	for strings.Contains(content, "<details>") {
		start := strings.Index(content, "<details>")
		end := strings.Index(content[start:], "</details>")
		if end == -1 {
			break
		}
		end += start + len("</details>")
		content = content[:start] + content[end:]
	}

	// Convert Hugo shortcodes to markdown code blocks
	content = strings.Replace(content, "{{< highlight yaml >}}", "```yaml", -1)
	content = strings.Replace(content, "{{< /highlight >}}", "```", -1)

	// Add newline between consecutive code blocks
	content = strings.Replace(content, "``````yaml", "```\n```yaml", -1)

	// Convert <br> to <br /> for MDX compatibility
	content = strings.Replace(content, "<br>", "<br />", -1)

	// Remove [] prefix from link text and move to href (must happen before fixAnchorLinks)
	content = cleanLinkText(content)

	// Fix anchor links - remove prefixes, lowercase, URL-encode brackets
	content = fixAnchorLinks(content)

	// Escape angle bracket placeholders
	content = escapeAngleBracketPlaceholders(content)

	// Wrap technical patterns in backticks for code formatting
	content = wrapTechnicalPatternsInBackticks(content)

	// Collapse all whitespace (including newlines) into single spaces for MDX compatibility
	// This prevents parsing errors with multi-line content in <td> tags
	content = strings.Join(strings.Fields(content), " ")

	return content
}

// wrapTechnicalPatternsInBackticks wraps patterns like memory_{some,full}_{avg10,avg60,avg300} in backticks
func wrapTechnicalPatternsInBackticks(content string) string {
	// Pattern: word characters, underscores, with {option1,option2,...} expansions
	// Examples: memory_{some,full}_{avg10,avg60,avg300,total}
	// Look for: starts with letter/underscore, contains {, }, commas, and underscores

	result := ""
	i := 0
	for i < len(content) {
		// Skip if already in backticks
		if i > 0 && content[i-1] == '`' {
			result += string(content[i])
			i++
			continue
		}

		// Check if we're at the start of a potential pattern
		// Pattern should start with a letter or underscore
		if (content[i] >= 'a' && content[i] <= 'z') ||
		   (content[i] >= 'A' && content[i] <= 'Z') ||
		   content[i] == '_' {

			// Look ahead to see if this contains the technical pattern markers
			start := i
			hasUnderscore := false
			hasBraces := false
			hasComma := false

			// Scan ahead to find the end of this potential pattern
			end := i
			for end < len(content) {
				ch := content[end]

				// Pattern continues with alphanumeric, underscore, braces, comma
				if (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||
				   (ch >= '0' && ch <= '9') || ch == '_' ||
				   ch == '{' || ch == '}' || ch == ',' {

					if ch == '_' {
						hasUnderscore = true
					}
					if ch == '{' || ch == '}' {
						hasBraces = true
					}
					if ch == ',' {
						hasComma = true
					}
					end++
				} else {
					break
				}
			}

			// If we found a pattern with underscores, braces, and commas, wrap it
			if end > start && hasUnderscore && hasBraces && hasComma {
				pattern := content[start:end]
				// Make sure it's not already wrapped in backticks
				if start == 0 || content[start-1] != '`' {
					result += "`" + pattern + "`"
					i = end
					continue
				}
			}
		}

		result += string(content[i])
		i++
	}

	return result
}

// cleanLinkText removes [] prefix from link text and moves it to href
func cleanLinkText(line string) string {
	result := ""
	i := 0
	for i < len(line) {
		// Look for pattern: <a href="#...">[]
		if i+9 < len(line) && line[i:i+9] == "<a href=\"" {
			hrefStart := i + 9

			// Find the closing quote of href
			hrefEnd := strings.Index(line[hrefStart:], "\"")
			if hrefEnd != -1 {
				hrefEnd += hrefStart
				href := line[hrefStart:hrefEnd]

				// Find the closing > of the tag
				tagEnd := strings.Index(line[hrefEnd:], ">")
				if tagEnd != -1 {
					tagEnd += hrefEnd

					// Check if the text after the tag starts with []
					textStart := tagEnd + 1
					hasBrackets := false
					if textStart+2 <= len(line) && line[textStart:textStart+2] == "[]" {
						hasBrackets = true
					}

					// Build the output
					result += "<a href=\""
					// Remove trailing dot from href before adding brackets
					href = strings.TrimSuffix(href, ".")
					result += href
					if hasBrackets && !strings.Contains(href, "[]") {
						// Add brackets to href if text has them but href doesn't
						result += "[]"
					}
					result += "\""
					result += line[hrefEnd+1 : tagEnd+1] // attributes and >

					// Skip the [] in text if present
					if hasBrackets {
						i = textStart + 2
					} else {
						i = textStart
					}
					continue
				}
			}
		}
		result += string(line[i])
		i++
	}
	return result
}

// convertCodeBlocksToHTML converts Hugo highlight shortcodes to HTML pre/code tags
func convertCodeBlocksToHTML(content string) string {
	result := content

	// Replace all occurrences of {{< highlight yaml >}}...{{< /highlight >}}
	for strings.Contains(result, "{{< highlight yaml >}}") {
		start := strings.Index(result, "{{< highlight yaml >}}")
		end := strings.Index(result[start:], "{{< /highlight >}}")
		if end == -1 {
			break
		}
		end += start

		// Extract the code between the tags
		codeStart := start + len("{{< highlight yaml >}}")
		code := result[codeStart:end]

		// Trim leading/trailing newlines but preserve internal formatting
		code = strings.Trim(code, "\n")

		// Escape HTML entities in code
		code = strings.Replace(code, "&", "&amp;", -1)
		code = strings.Replace(code, "<", "&lt;", -1)
		code = strings.Replace(code, ">", "&gt;", -1)

		// Use simple code tag with preserved newlines
		// Put opening and closing tags on separate lines from the code content
		replacement := "<code>\n" + code + "\n</code>"

		result = result[:start] + replacement + result[end+len("{{< /highlight >}}"):]
	}

	return result
}

// convertTableToHTML converts a markdown table to HTML table
func convertTableToHTML(lines []string, startIdx int) (string, int) {
	if len(lines) < startIdx+2 {
		return "", startIdx
	}

	// Parse header row
	headerCells, nextIdx := parseTableRow(lines, startIdx)

	// Parse separator row to get alignments
	if nextIdx >= len(lines) || !isTableSeparator(lines[nextIdx]) {
		return "", startIdx
	}
	alignments := parseTableAlignment(lines[nextIdx])
	nextIdx++

	// Build HTML table
	var html strings.Builder
	html.WriteString("<table>\n")

	// Build header
	html.WriteString("  <thead>\n")
	html.WriteString("    <tr>\n")
	for i, cell := range headerCells {
		align := ""
		if i < len(alignments) && alignments[i] != "" {
			align = fmt.Sprintf(` style="text-align: %s"`, alignments[i])
		}
		processedCell := processCellContent(cell)
		html.WriteString(fmt.Sprintf("      <th%s>%s</th>\n", align, processedCell))
	}
	html.WriteString("    </tr>\n")
	html.WriteString("  </thead>\n")

	// Build body rows
	html.WriteString("  <tbody>\n")
	for nextIdx < len(lines) {
		line := strings.TrimSpace(lines[nextIdx])

		// Check if this is still a table row
		if !strings.HasPrefix(line, "|") || line == "" {
			break
		}

		cells, newIdx := parseTableRow(lines, nextIdx)
		html.WriteString("    <tr>\n")
		for i, cell := range cells {
			align := ""
			if i < len(alignments) && alignments[i] != "" {
				align = fmt.Sprintf(` style="text-align: %s"`, alignments[i])
			}
			processedCell := processCellContent(cell)
			html.WriteString(fmt.Sprintf("      <td%s>%s</td>\n", align, processedCell))
		}
		html.WriteString("    </tr>\n")
		nextIdx = newIdx
	}
	html.WriteString("  </tbody>\n")

	html.WriteString("</table>")

	return html.String(), nextIdx
}

func main() {
	if len(os.Args) < 3 {
		fmt.Println("Usage: convert-docs <source_file_or_dir> <dest_file_or_dir>")
		os.Exit(1)
	}

	src := os.Args[1]
	dst := os.Args[2]

	// Check if source is a file or directory
	srcInfo, err := os.Stat(src)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error accessing source: %v\n", err)
		os.Exit(1)
	}

	// Single file conversion
	if !srcInfo.IsDir() {
		if !strings.HasSuffix(src, ".md") {
			fmt.Fprintf(os.Stderr, "Error: source file must be a .md file\n")
			os.Exit(1)
		}

		// Skip _index.md files
		if strings.Contains(src, "_index.md") {
			fmt.Printf("Skipping _index.md file\n")
			os.Exit(0)
		}

		// Determine the destination file path
		dstPath := dst

		// Check if destination is a directory or should be treated as one
		dstInfo, err := os.Stat(dst)
		if err == nil && dstInfo.IsDir() {
			// Destination exists and is a directory - derive filename from source
			srcBase := filepath.Base(src)
			dstFilename := strings.TrimSuffix(srcBase, ".md") + ".mdx"
			dstPath = filepath.Join(dst, dstFilename)
		} else if err != nil && (strings.HasSuffix(dst, "/") || strings.HasSuffix(dst, "\\")) {
			// Destination doesn't exist but ends with slash - treat as directory
			srcBase := filepath.Base(src)
			dstFilename := strings.TrimSuffix(srcBase, ".md") + ".mdx"
			dstPath = filepath.Join(dst, dstFilename)
		}

		fmt.Printf("Converting single file: %s -> %s\n", src, dstPath)

		// Create destination directory if it doesn't exist
		if err := os.MkdirAll(filepath.Dir(dstPath), 0755); err != nil {
			fmt.Fprintf(os.Stderr, "Error creating destination directory: %v\n", err)
			os.Exit(1)
		}

		// Convert the file
		if err := convertFile(src, dstPath); err != nil {
			fmt.Fprintf(os.Stderr, "Error converting file: %v\n", err)
			os.Exit(1)
		}

		fmt.Println("Conversion complete!")
		return
	}

	// Directory conversion (existing behavior)
	srcDir := src
	dstDir := dst

	fmt.Printf("Converting docs from %s to %s\n", srcDir, dstDir)

	// Files to preserve during conversion (don't delete these)
	preserveFiles := map[string]bool{
		"overview.mdx": true,
	}

	// Instead of removing entire directory, selectively remove only generated files
	// This preserves manually created files like overview.mdx
	if _, err := os.Stat(dstDir); err == nil {
		// Directory exists, remove only .mdx files that aren't in preserve list
		filepath.Walk(dstDir, func(path string, info os.FileInfo, err error) error {
			if err != nil || info.IsDir() {
				return nil
			}

			filename := filepath.Base(path)
			if !preserveFiles[filename] && strings.HasSuffix(path, ".mdx") {
				os.Remove(path)
			}
			return nil
		})
	} else {
		// Directory doesn't exist, create it
		os.MkdirAll(dstDir, 0755)
	}

	// Walk through source directory
	err = filepath.Walk(srcDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() {
			return nil
		}

		if !strings.HasSuffix(path, ".md") {
			return nil
		}

		relPath, err := filepath.Rel(srcDir, path)
		if err != nil {
			return err
		}

		// Skip _index.md files
		if strings.Contains(relPath, "_index.md") {
			fmt.Printf("Skipping %s\n", relPath)
			return nil
		}

		// Convert .md to .mdx
		dstPath := filepath.Join(dstDir, strings.TrimSuffix(relPath, ".md")+".mdx")

		// Create destination directory
		if err := os.MkdirAll(filepath.Dir(dstPath), 0755); err != nil {
			return err
		}

		fmt.Printf("Converting %s -> %s\n", relPath, strings.TrimSuffix(relPath, ".md")+".mdx")

		return convertFile(path, dstPath)
	})

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	// Count converted files
	count := 0
	filepath.Walk(dstDir, func(path string, info os.FileInfo, err error) error {
		if err == nil && !info.IsDir() && strings.HasSuffix(path, ".mdx") {
			count++
		}
		return nil
	})

	fmt.Println("Conversion complete!")
	fmt.Printf("Converted files: %d\n", count)
}
