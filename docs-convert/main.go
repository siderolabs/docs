package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

func convertFile(srcPath, dstPath string) error {
	src, err := os.Open(srcPath)
	if err != nil {
		return err
	}
	defer src.Close()

	dst, err := os.Create(dstPath)
	if err != nil {
		return err
	}
	defer dst.Close()

	scanner := bufio.NewScanner(src)
	writer := bufio.NewWriter(dst)
	defer writer.Flush()

	var lines []string
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		return err
	}

	// Check if this is the v1alpha1/config file or cli file
	isConfigFile := strings.Contains(dstPath, "v1alpha1/config.mdx") || strings.Contains(dstPath, "v1alpha1\\config.mdx")
	isCliFile := strings.HasSuffix(dstPath, "/cli.mdx") || strings.HasSuffix(dstPath, "\\cli.mdx")
	isWideMode := isConfigFile || isCliFile

	// Process lines
	i := 0
	inFrontmatter := false
	for i < len(lines) {
		line := lines[i]

		// Track frontmatter boundaries
		if line == "---" {
			if !inFrontmatter {
				inFrontmatter = true
				fmt.Fprintln(writer, line)
				i++
				continue
			} else {
				// End of frontmatter - add mode: "wide" for config and cli files
				if isWideMode {
					fmt.Fprintln(writer, "mode: \"wide\"")
				}
				inFrontmatter = false
				fmt.Fprintln(writer, line)
				// Add auto-generated comment after frontmatter
				fmt.Fprintln(writer, "")
				fmt.Fprintln(writer, "{/*")
				fmt.Fprintln(writer, "This file is automatically generated from source documentation.")
				fmt.Fprintln(writer, "Do not edit manually. For more information, see https://github.com/siderolabs/docs")
				fmt.Fprintln(writer, "*/}")
				i++
				continue
			}
		}

		// Handle title in frontmatter for config and cli files
		if inFrontmatter && strings.HasPrefix(line, "title:") {
			if isConfigFile {
				fmt.Fprintln(writer, "title: MachineConfig")
				i++
				continue
			}
			if isCliFile {
				fmt.Fprintln(writer, "title: talosctl")
				i++
				continue
			}
		}

		// Handle multi-line description in frontmatter
		if inFrontmatter && strings.HasPrefix(line, "description: |") {
			// Collect all indented lines that follow
			descriptionParts := []string{}
			i++
			for i < len(lines) && len(lines[i]) > 0 && (lines[i][0] == ' ' || lines[i][0] == '\t') {
				// Remove leading whitespace and add to parts
				descriptionParts = append(descriptionParts, strings.TrimSpace(lines[i]))
				i++
			}
			// Join all parts into a single line
			singleLineDescription := strings.Join(descriptionParts, " ")
			// Escape single quotes in the description
			singleLineDescription = strings.Replace(singleLineDescription, "'", "''", -1)
			// Quote the description with single quotes to handle special characters
			fmt.Fprintf(writer, "description: '%s'\n", singleLineDescription)
			continue
		}

		// Check if this line starts an Accordion with inline code
		if strings.Contains(line, "<details><summary>") {
			// Find the end of the Accordion (</details>)
			endLine := i
			for endLine < len(lines) && !strings.Contains(lines[endLine], "</details>") {
				endLine++
			}

			if endLine < len(lines) {
				// Collect all lines in the Accordion
				accordionLines := append([]string{line}, lines[i+1:endLine+1]...)
				fullContent := strings.Join(accordionLines, "\n")

				// Replace tags
				fullContent = strings.Replace(fullContent, "<details><summary>", "<Accordion title=\"", 1)
				fullContent = strings.Replace(fullContent, "</summary>", "\">", 1)
				fullContent = strings.Replace(fullContent, "</details>", "</Accordion>", 1)

				// Convert Hugo shortcodes to markdown code blocks
				fullContent = strings.Replace(fullContent, "{{< highlight yaml >}}", "```yaml", -1)
				fullContent = strings.Replace(fullContent, "{{< /highlight >}}", "```", -1)

				// Convert <br> to <br /> for MDX compatibility
				fullContent = strings.Replace(fullContent, "<br>", "<br />", -1)

				fmt.Fprintln(writer, fullContent)
				i = endLine + 1
				continue
			}
		}

		// Check if this line starts a markdown table (must be outside frontmatter)
		if !inFrontmatter && detectTableStart(line) {
			// Look ahead to see if next line is separator
			if i+1 < len(lines) && isTableSeparator(lines[i+1]) {
				// Convert table to HTML
				tableHTML, endIdx := convertTableToHTML(lines, i)
				if tableHTML != "" {
					fmt.Fprintln(writer, tableHTML)
					i = endIdx
					continue
				}
			}
		}

		// Handle regular lines - convert Hugo shortcodes to code blocks
		line = strings.Replace(line, "{{< highlight yaml >}}", "```yaml", -1)
		line = strings.Replace(line, "{{< /highlight >}}", "```", -1)

		// Convert <br> to <br /> for MDX compatibility
		line = strings.Replace(line, "<br>", "<br />", -1)

		// Skip markdownlint-disable comments
		if strings.Contains(line, "<!-- markdownlint-disable -->") {
			i++
			continue
		}

		// Remove {#anchor-id} from headings (MDX doesn't support this syntax)
		if strings.HasPrefix(strings.TrimSpace(line), "#") && strings.Contains(line, "{#") {
			start := strings.Index(line, "{#")
			end := strings.Index(line, "}")
			if end > start && end != -1 {
				line = strings.TrimSpace(line[:start] + line[end+1:])
			}
		}

		// Fix anchor links - remove page name prefix (e.g., #Config.machine -> #machine)
		line = fixAnchorLinks(line)

		// Escape placeholder-like angle brackets (e.g., <src-path>, <dest-path>)
		// but preserve actual HTML tags (a, br, Accordion)
		// Simple heuristic: if it contains a hyphen or underscore, it's likely a placeholder
		line = escapeAngleBracketPlaceholders(line)

		fmt.Fprintln(writer, line)
		i++
	}

	return nil
}

func fixAnchorLinks(line string) string {
	// Find and fix all href="#..." patterns
	result := ""
	for {
		// Find next href="#
		start := strings.Index(line, "href=\"#")
		if start == -1 {
			result += line
			break
		}

		// Add everything before the href including 'href="#'
		result += line[:start+7] // include 'href="#'
		line = line[start+7:]    // skip past 'href="#'

		// Find the closing quote
		end := strings.Index(line, "\"")
		if end == -1 {
			// Malformed, just add rest and break
			result += line
			break
		}

		// Extract the anchor value
		anchor := line[:end]

		// Fix the anchor by taking the last segment
		// Handle anchors ending with dot (e.g., "Config.foo.bar." -> "bar.")
		if strings.Contains(anchor, ".") {
			endsWithDot := strings.HasSuffix(anchor, ".")
			if endsWithDot {
				// Remove trailing dot temporarily
				anchor = anchor[:len(anchor)-1]
			}

			// Find the last dot and take everything after it
			lastDot := strings.LastIndex(anchor, ".")
			if lastDot != -1 {
				anchor = anchor[lastDot+1:]
			}

			// Restore trailing dot if it was there
			if endsWithDot {
				anchor = anchor + "."
			}
		}

		result += anchor + "\""
		line = line[end+1:]
	}

	return result
}

func escapeAngleBracketPlaceholders(line string) string {
	result := ""
	i := 0
	for i < len(line) {
		// Check for Hugo shortcode start pattern {{<
		if i+2 < len(line) && line[i:i+3] == "{{<" {
			// Find the closing >}}
			end := strings.Index(line[i:], ">}}")
			if end != -1 {
				// Skip the entire Hugo shortcode
				end = i + end + 3 // +3 for ">}}"
				result += line[i:end]
				i = end
				continue
			}
		}

		if line[i] == '<' {
			// Find the closing >
			end := i + 1
			for end < len(line) && line[end] != '>' {
				end++
			}
			if end < len(line) {
				// Extract the content between < and >
				content := line[i+1 : end]
				// Check if it's likely a placeholder or text that should not be parsed as HTML
				// Known HTML tags we want to preserve: a, br, Accordion, details, summary, pre, code and their closing tags
				isKnownTag := strings.HasPrefix(content, "a ") ||
					strings.HasPrefix(content, "br") ||
					strings.HasPrefix(content, "Accordion") ||
					strings.HasPrefix(content, "details") ||
					strings.HasPrefix(content, "summary") ||
					strings.HasPrefix(content, "pre") ||
					strings.HasPrefix(content, "code") ||
					content == "/a" ||
					content == "/br" ||
					content == "/Accordion" ||
					content == "/details" ||
					content == "/summary" ||
					content == "/pre" ||
					content == "/code"

				// If it's not a known HTML tag, escape using JSX expressions
				if !isKnownTag {
					result += `{"<"}` + content + `{">"}`
					i = end + 1
					continue
				}
			}
		}
		result += string(line[i])
		i++
	}
	return result
}

// detectTableStart checks if a line is the start of a markdown table
func detectTableStart(line string) bool {
	trimmed := strings.TrimSpace(line)
	return strings.Contains(trimmed, "|") && !strings.HasPrefix(trimmed, "{{< highlight")
}

// isTableSeparator checks if a line is the separator row (e.g., |---|---|)
func isTableSeparator(line string) bool {
	trimmed := strings.TrimSpace(line)
	if !strings.Contains(trimmed, "|") {
		return false
	}
	// Remove pipes and trim
	content := strings.Trim(trimmed, "|")
	parts := strings.Split(content, "|")
	for _, part := range parts {
		part = strings.TrimSpace(part)
		// Check if it's composed of hyphens and optional colons for alignment
		if len(part) == 0 {
			return false
		}
		for _, ch := range part {
			if ch != '-' && ch != ':' {
				return false
			}
		}
	}
	return true
}

// parseTableAlignment extracts column alignment from separator row
func parseTableAlignment(line string) []string {
	trimmed := strings.TrimSpace(line)
	content := strings.Trim(trimmed, "|")
	parts := strings.Split(content, "|")
	alignments := make([]string, len(parts))

	for i, part := range parts {
		part = strings.TrimSpace(part)
		hasLeft := strings.HasPrefix(part, ":")
		hasRight := strings.HasSuffix(part, ":")

		if hasLeft && hasRight {
			alignments[i] = "center"
		} else if hasRight {
			alignments[i] = "right"
		} else if hasLeft {
			alignments[i] = "left"
		} else {
			alignments[i] = ""
		}
	}
	return alignments
}

// parseTableRow extracts cells from a table row (handles multi-line cells)
func parseTableRow(lines []string, startIdx int) ([]string, int) {
	// Collect lines until we find the next row or end of table
	rowLines := []string{lines[startIdx]}
	currentIdx := startIdx + 1
	emptyLineCount := 0

	// Keep adding lines until we find another row (starts with |) or reach end
	for currentIdx < len(lines) {
		line := lines[currentIdx]
		trimmed := strings.TrimSpace(line)

		// If line starts with |, it's the next row
		if strings.HasPrefix(trimmed, "|") {
			break
		}

		// Count consecutive empty lines - only break after 2+ empty lines
		// (single empty lines can be part of code blocks in table cells)
		if trimmed == "" {
			emptyLineCount++
			if emptyLineCount >= 2 {
				break
			}
		} else {
			emptyLineCount = 0
		}

		// Add to current row
		rowLines = append(rowLines, line)
		currentIdx++
	}

	// Join all lines and parse
	fullRow := strings.Join(rowLines, "\n")
	trimmed := strings.TrimSpace(fullRow)
	content := strings.Trim(trimmed, "|")

	// Split by | but be smarter about it - handle | inside <details> tags
	cells := make([]string, 0)
	currentCell := ""
	inDetails := false
	i := 0

	for i < len(content) {
		// Check for <details> opening
		if i+8 <= len(content) && content[i:i+8] == "<details" {
			inDetails = true
		}
		// Check for </details> closing
		if i+10 <= len(content) && content[i:i+10] == "</details>" {
			currentCell += "</details>"
			i += 10
			inDetails = false
			continue
		}

		// If we hit a | and we're not inside <details>, it's a cell separator
		if content[i] == '|' && !inDetails {
			cells = append(cells, strings.TrimSpace(currentCell))
			currentCell = ""
			i++
			continue
		}

		currentCell += string(content[i])
		i++
	}

	// Add the last cell
	if len(currentCell) > 0 || len(cells) > 0 {
		cells = append(cells, strings.TrimSpace(currentCell))
	}

	return cells, currentIdx
}

// processCellContent applies transformations to cell content
func processCellContent(content string) string {
	// Remove <details> blocks entirely
	for strings.Contains(content, "<details>") {
		start := strings.Index(content, "<details>")
		end := strings.Index(content[start:], "</details>")
		if end == -1 {
			break
		}
		end += start + len("</details>")
		content = content[:start] + content[end:]
	}

	// Convert Hugo shortcodes to markdown code blocks
	content = strings.Replace(content, "{{< highlight yaml >}}", "```yaml", -1)
	content = strings.Replace(content, "{{< /highlight >}}", "```", -1)

	// Add newline between consecutive code blocks
	content = strings.Replace(content, "``````yaml", "```\n```yaml", -1)

	// Convert <br> to <br /> for MDX compatibility
	content = strings.Replace(content, "<br>", "<br />", -1)

	// Fix anchor links - remove prefixes (e.g., #Config.machine -> #machine)
	content = fixAnchorLinks(content)

	// Escape angle bracket placeholders
	content = escapeAngleBracketPlaceholders(content)

	return content
}

// convertCodeBlocksToHTML converts Hugo highlight shortcodes to HTML pre/code tags
func convertCodeBlocksToHTML(content string) string {
	result := content

	// Replace all occurrences of {{< highlight yaml >}}...{{< /highlight >}}
	for strings.Contains(result, "{{< highlight yaml >}}") {
		start := strings.Index(result, "{{< highlight yaml >}}")
		end := strings.Index(result[start:], "{{< /highlight >}}")
		if end == -1 {
			break
		}
		end += start

		// Extract the code between the tags
		codeStart := start + len("{{< highlight yaml >}}")
		code := result[codeStart:end]

		// Trim leading/trailing newlines but preserve internal formatting
		code = strings.Trim(code, "\n")

		// Escape HTML entities in code
		code = strings.Replace(code, "&", "&amp;", -1)
		code = strings.Replace(code, "<", "&lt;", -1)
		code = strings.Replace(code, ">", "&gt;", -1)

		// Use simple code tag with preserved newlines
		// Put opening and closing tags on separate lines from the code content
		replacement := "<code>\n" + code + "\n</code>"

		result = result[:start] + replacement + result[end+len("{{< /highlight >}}"):]
	}

	return result
}

// convertTableToHTML converts a markdown table to HTML table
func convertTableToHTML(lines []string, startIdx int) (string, int) {
	if len(lines) < startIdx+2 {
		return "", startIdx
	}

	// Parse header row
	headerCells, nextIdx := parseTableRow(lines, startIdx)

	// Parse separator row to get alignments
	if nextIdx >= len(lines) || !isTableSeparator(lines[nextIdx]) {
		return "", startIdx
	}
	alignments := parseTableAlignment(lines[nextIdx])
	nextIdx++

	// Build HTML table
	var html strings.Builder
	html.WriteString("<table>\n")

	// Build header
	html.WriteString("  <thead>\n")
	html.WriteString("    <tr>\n")
	for i, cell := range headerCells {
		align := ""
		if i < len(alignments) && alignments[i] != "" {
			align = fmt.Sprintf(` style="text-align: %s"`, alignments[i])
		}
		processedCell := processCellContent(cell)
		html.WriteString(fmt.Sprintf("      <th%s>%s</th>\n", align, processedCell))
	}
	html.WriteString("    </tr>\n")
	html.WriteString("  </thead>\n")

	// Build body rows
	html.WriteString("  <tbody>\n")
	for nextIdx < len(lines) {
		line := strings.TrimSpace(lines[nextIdx])

		// Check if this is still a table row
		if !strings.HasPrefix(line, "|") || line == "" {
			break
		}

		cells, newIdx := parseTableRow(lines, nextIdx)
		html.WriteString("    <tr>\n")
		for i, cell := range cells {
			align := ""
			if i < len(alignments) && alignments[i] != "" {
				align = fmt.Sprintf(` style="text-align: %s"`, alignments[i])
			}
			processedCell := processCellContent(cell)
			html.WriteString(fmt.Sprintf("      <td%s>%s</td>\n", align, processedCell))
		}
		html.WriteString("    </tr>\n")
		nextIdx = newIdx
	}
	html.WriteString("  </tbody>\n")

	html.WriteString("</table>")

	return html.String(), nextIdx
}

func main() {
	if len(os.Args) < 3 {
		fmt.Println("Usage: convert-docs <source_dir> <dest_dir>")
		os.Exit(1)
	}

	srcDir := os.Args[1]
	dstDir := os.Args[2]

	fmt.Printf("Converting docs from %s to %s\n", srcDir, dstDir)

	// Remove and recreate destination directory
	os.RemoveAll(dstDir)
	os.MkdirAll(dstDir, 0755)

	// Walk through source directory
	err := filepath.Walk(srcDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() {
			return nil
		}

		if !strings.HasSuffix(path, ".md") {
			return nil
		}

		relPath, err := filepath.Rel(srcDir, path)
		if err != nil {
			return err
		}

		// Skip _index.md files
		if strings.Contains(relPath, "_index.md") {
			fmt.Printf("Skipping %s\n", relPath)
			return nil
		}

		// Convert .md to .mdx
		dstPath := filepath.Join(dstDir, strings.TrimSuffix(relPath, ".md")+".mdx")

		// Create destination directory
		if err := os.MkdirAll(filepath.Dir(dstPath), 0755); err != nil {
			return err
		}

		fmt.Printf("Converting %s -> %s\n", relPath, strings.TrimSuffix(relPath, ".md")+".mdx")

		return convertFile(path, dstPath)
	})

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	// Count converted files
	count := 0
	filepath.Walk(dstDir, func(path string, info os.FileInfo, err error) error {
		if err == nil && !info.IsDir() && strings.HasSuffix(path, ".mdx") {
			count++
		}
		return nil
	})

	fmt.Println("Conversion complete!")
	fmt.Printf("Converted files: %d\n", count)
}
