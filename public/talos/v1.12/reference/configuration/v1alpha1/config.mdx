---
description: Config defines the v1alpha1.Config Talos machine configuration document.
title: MachineConfig
mode: "wide"
---

{/*
This file is automatically generated from source documentation.
Do not edit manually. For more information, see https://github.com/siderolabs/docs
*/}










```yaml
version: v1alpha1
machine: # ...
cluster: # ...
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`version`</td>
      <td>string</td>
      <td>Indicates the schema used to decode the contents.</td>
      <td>`v1alpha1`<br /></td>
    </tr>
    <tr>
      <td>`debug`</td>
      <td>bool</td>
      <td>Enable verbose logging to the console.<br />All system containers logs will flow into serial console.<br /><br />**Note:** To avoid breaking Talos bootstrap flow enable this option only if serial console can handle high message throughput.</td>
      <td>`true`<br />`yes`<br />`false`<br />`no`<br /></td>
    </tr>
    <tr>
      <td>`machine`</td>
      <td><a href="#machine">MachineConfig</a></td>
      <td>Provides machine specific configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`cluster`</td>
      <td><a href="#cluster">ClusterConfig</a></td>
      <td>Provides cluster specific configuration options.</td>
      <td></td>
    </tr>
  </tbody>
</table>



## machine

MachineConfig represents the machine-specific config values.



```yaml
machine:
    type: controlplane
    # InstallConfig represents the installation options for preparing a node.
    install:
        disk: /dev/sda # The disk used for installations.
        # Allows for supplying extra kernel args via the bootloader.
        extraKernelArgs:
            - console=ttyS1
            - panic=10
        image: ghcr.io/siderolabs/installer:latest # Allows for supplying the image used to perform the installation.
        wipe: false # Indicates if the installation disk should be wiped at installation time.

        # # Look up disk using disk attributes like model, size, serial and others.
        # diskSelector:
        #     size: 4GB # Disk size.
        #     model: WDC* # Disk model `/sys/block/{"<"}dev{">"}/device/model`.
        #     busPath: /pci0000:00/0000:00:17.0/ata1/host0/target0:0:0/0:0:0:0 # Disk bus path.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`type`</td>
      <td>string</td>
      <td>Defines the role of the machine within the cluster.<br /><br />**Control Plane**<br /><br />Control Plane node type designates the node as a control plane member.<br />This means it will host etcd along with the Kubernetes controlplane components such as API Server, Controller Manager, Scheduler.<br /><br />**Worker**<br /><br />Worker node type designates the node as a worker node.<br />This means it will be an available compute node for scheduling workloads.<br /><br />This node type was previously known as "join"; that value is still supported but deprecated.</td>
      <td>`controlplane`<br />`worker`<br /></td>
    </tr>
    <tr>
      <td>`token`</td>
      <td>string</td>
      <td>The `token` is used by a machine to join the PKI of the cluster.<br />Using this token, a machine will create a certificate signing request (CSR), and request a certificate that will be used as its' identity.</td>
      <td></td>
    </tr>
    <tr>
      <td>`ca`</td>
      <td>PEMEncodedCertificateAndKey</td>
      <td>The root certificate authority of the PKI.<br />It is composed of a base64 encoded `crt` and `key`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`acceptedCAs`</td>
      <td>[]PEMEncodedCertificate</td>
      <td>The certificates issued by certificate authorities are accepted in addition to issuing 'ca'.<br />It is composed of a base64 encoded `crt``.</td>
      <td></td>
    </tr>
    <tr>
      <td>`certSANs`</td>
      <td>[]string</td>
      <td>Extra certificate subject alternative names for the machine's certificate.<br />By default, all non-loopback interface IPs are automatically added to the certificate's SANs.</td>
      <td></td>
    </tr>
    <tr>
      <td>`controlPlane`</td>
      <td><a href="#controlPlane">MachineControlPlaneConfig</a></td>
      <td>Provides machine specific control plane configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`kubelet`</td>
      <td><a href="#kubelet">KubeletConfig</a></td>
      <td>Used to provide additional options to the kubelet.</td>
      <td></td>
    </tr>
    <tr>
      <td>`pods`</td>
      <td>[]Unstructured</td>
      <td>Used to provide static pod definitions to be run by the kubelet directly bypassing the kube-apiserver.<br /><br />Static pods can be used to run components which should be started before the Kubernetes control plane is up.<br />Talos doesn't validate the pod definition.<br />Updates to this field can be applied without a reboot.<br /><br />See https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/.</td>
      <td></td>
    </tr>
    <tr>
      <td>`network`</td>
      <td><a href="#network">NetworkConfig</a></td>
      <td>Provides machine specific network configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`install`</td>
      <td><a href="#install">InstallConfig</a></td>
      <td>Used to provide instructions for installations.<br /><br />Note that this configuration section gets silently ignored by Talos images that are considered pre-installed.<br />To make sure Talos installs according to the provided configuration, Talos should be booted with ISO or PXE-booted.</td>
      <td></td>
    </tr>
    <tr>
      <td>`files`</td>
      <td><a href="#files.">[]MachineFile</a></td>
      <td>Allows the addition of user specified files.<br />The value of `op` can be `create`, `overwrite`, or `append`.<br />In the case of `create`, `path` must not exist.<br />In the case of `overwrite`, and `append`, `path` must be a valid file.<br />If an `op` value of `append` is used, the existing file will be appended.<br />Note that the file contents are not required to be base64 encoded.</td>
      <td></td>
    </tr>
    <tr>
      <td>`env`</td>
      <td>Env</td>
      <td>The `env` field allows for the addition of environment variables.<br />All environment variables are set on PID 1 in addition to every service.</td>
      <td>``GRPC_GO_LOG_VERBOSITY_LEVEL``<br />``GRPC_GO_LOG_SEVERITY_LEVEL``<br />``http_proxy``<br />``https_proxy``<br />``no_proxy``<br /></td>
    </tr>
    <tr>
      <td>`time`</td>
      <td><a href="#time">TimeConfig</a></td>
      <td>Used to configure the machine's time settings.</td>
      <td></td>
    </tr>
    <tr>
      <td>`sysctls`</td>
      <td>map[string]string</td>
      <td>Used to configure the machine's sysctls.</td>
      <td></td>
    </tr>
    <tr>
      <td>`sysfs`</td>
      <td>map[string]string</td>
      <td>Used to configure the machine's sysfs.</td>
      <td></td>
    </tr>
    <tr>
      <td>`registries`</td>
      <td><a href="#registries">RegistriesConfig</a></td>
      <td>Used to configure the machine's container image registry mirrors.<br /><br />Automatically generates matching CRI configuration for registry mirrors.<br /><br />The `mirrors` section allows to redirect requests for images to a non-default registry,<br />which might be a local registry or a caching mirror.<br /><br />The `config` section provides a way to authenticate to the registry with TLS client<br />identity, provide registry CA, or authentication information.<br />Authentication information has same meaning with the corresponding field in [`.docker/config.json`](https://docs.docker.com/engine/api/v1.41/#section/Authentication).<br /><br />See also matching configuration for [CRI containerd plugin](https://github.com/containerd/cri/blob/master/docs/registry.md).</td>
      <td></td>
    </tr>
    <tr>
      <td>`features`</td>
      <td><a href="#features">FeaturesConfig</a></td>
      <td>Features describe individual Talos features that can be switched on or off.</td>
      <td></td>
    </tr>
    <tr>
      <td>`udev`</td>
      <td><a href="#udev">UdevConfig</a></td>
      <td>Configures the udev system.</td>
      <td></td>
    </tr>
    <tr>
      <td>`logging`</td>
      <td><a href="#logging">LoggingConfig</a></td>
      <td>Configures the logging system.</td>
      <td></td>
    </tr>
    <tr>
      <td>`kernel`</td>
      <td><a href="#kernel">KernelConfig</a></td>
      <td>Configures the kernel.</td>
      <td></td>
    </tr>
    <tr>
      <td>`seccompProfiles`</td>
      <td><a href="#seccompProfiles.">[]MachineSeccompProfile</a></td>
      <td>Configures the seccomp profiles for the machine.</td>
      <td></td>
    </tr>
    <tr>
      <td>`baseRuntimeSpecOverrides`</td>
      <td>Unstructured</td>
      <td>Override (patch) settings in the default OCI runtime spec for CRI containers.<br /><br />It can be used to set some default container settings which are not configurable in Kubernetes,<br />for example default ulimits.<br />Note: this change applies to all newly created containers, and it requires a reboot to take effect.</td>
      <td></td>
    </tr>
    <tr>
      <td>`nodeLabels`</td>
      <td>map[string]string</td>
      <td>Configures the node labels for the machine.<br /><br />Note: In the default Kubernetes configuration, worker nodes are restricted to set<br />labels with some prefixes (see [NodeRestriction](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction) admission plugin).</td>
      <td></td>
    </tr>
    <tr>
      <td>`nodeAnnotations`</td>
      <td>map[string]string</td>
      <td>Configures the node annotations for the machine.</td>
      <td></td>
    </tr>
    <tr>
      <td>`nodeTaints`</td>
      <td>map[string]string</td>
      <td>Configures the node taints for the machine. Effect is optional.<br /><br />Note: In the default Kubernetes configuration, worker nodes are not allowed to<br />modify the taints (see [NodeRestriction](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction) admission plugin).</td>
      <td></td>
    </tr>
  </tbody>
</table>



### controlPlane

MachineControlPlaneConfig machine specific configuration options.



```yaml
machine:
    controlPlane:
        # Controller manager machine specific configuration options.
        controllerManager:
            disabled: false # Disable kube-controller-manager on the node.
        # Scheduler machine specific configuration options.
        scheduler:
            disabled: true # Disable kube-scheduler on the node.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`controllerManager`</td>
      <td><a href="#controllerManager">MachineControllerManagerConfig</a></td>
      <td>Controller manager machine specific configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`scheduler`</td>
      <td><a href="#scheduler">MachineSchedulerConfig</a></td>
      <td>Scheduler machine specific configuration options.</td>
      <td></td>
    </tr>
  </tbody>
</table>



#### controllerManager

MachineControllerManagerConfig represents the machine specific ControllerManager config values.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`disabled`</td>
      <td>bool</td>
      <td>Disable kube-controller-manager on the node.</td>
      <td></td>
    </tr>
  </tbody>
</table>





#### scheduler

MachineSchedulerConfig represents the machine specific Scheduler config values.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`disabled`</td>
      <td>bool</td>
      <td>Disable kube-scheduler on the node.</td>
      <td></td>
    </tr>
  </tbody>
</table>







### kubelet

KubeletConfig represents the kubelet config values.



```yaml
machine:
    kubelet:
        image: ghcr.io/siderolabs/kubelet:v1.34.1 # The `image` field is an optional reference to an alternative kubelet image.
        # The `extraArgs` field is used to provide additional flags to the kubelet.
        extraArgs:
            feature-gates: ServerSideApply=true

        # # The `ClusterDNS` field is an optional reference to an alternative kubelet clusterDNS ip list.
        # clusterDNS:
        #     - 10.96.0.10
        #     - 169.254.2.53

        # # The `extraMounts` field is used to add additional mounts to the kubelet container.
        # extraMounts:
        #     - destination: /var/lib/example # Destination is the absolute path where the mount will be placed in the container.
        #       type: bind # Type specifies the mount kind.
        #       source: /var/lib/example # Source specifies the source path of the mount.
        #       # Options are fstab style mount options.
        #       options:
        #         - bind
        #         - rshared
        #         - rw

        # # The `extraConfig` field is used to provide kubelet configuration overrides.
        # extraConfig:
        #     serverTLSBootstrap: true

        # # The `KubeletCredentialProviderConfig` field is used to provide kubelet credential configuration.
        # credentialProviderConfig:
        #     apiVersion: kubelet.config.k8s.io/v1
        #     kind: CredentialProviderConfig
        #     providers:
        #         - apiVersion: credentialprovider.kubelet.k8s.io/v1
        #           defaultCacheDuration: 12h
        #           matchImages:
        #             - '*.dkr.ecr.*.amazonaws.com'
        #             - '*.dkr.ecr.*.amazonaws.com.cn'
        #             - '*.dkr.ecr-fips.*.amazonaws.com'
        #             - '*.dkr.ecr.us-iso-east-1.c2s.ic.gov'
        #             - '*.dkr.ecr.us-isob-east-1.sc2s.sgov.gov'
        #           name: ecr-credential-provider

        # # The `nodeIP` field is used to configure `--node-ip` flag for the kubelet.
        # nodeIP:
        #     # The `validSubnets` field configures the networks to pick kubelet node IP from.
        #     validSubnets:
        #         - 10.0.0.0/8
        #         - '!10.0.0.3/32'
        #         - fdc7::/16
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`image`</td>
      <td>string</td>
      <td>The `image` field is an optional reference to an alternative kubelet image.</td>
      <td></td>
    </tr>
    <tr>
      <td>`clusterDNS`</td>
      <td>[]string</td>
      <td>The `ClusterDNS` field is an optional reference to an alternative kubelet clusterDNS ip list.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraArgs`</td>
      <td>map[string]string</td>
      <td>The `extraArgs` field is used to provide additional flags to the kubelet.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraMounts`</td>
      <td><a href="#extraMounts.">[]ExtraMount</a></td>
      <td>The `extraMounts` field is used to add additional mounts to the kubelet container.<br />Note that either `bind` or `rbind` are required in the `options`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraConfig`</td>
      <td>Unstructured</td>
      <td>The `extraConfig` field is used to provide kubelet configuration overrides.<br /><br />Some fields are not allowed to be overridden: authentication and authorization, cgroups<br />configuration, ports, etc.</td>
      <td></td>
    </tr>
    <tr>
      <td>`credentialProviderConfig`</td>
      <td>Unstructured</td>
      <td>The `KubeletCredentialProviderConfig` field is used to provide kubelet credential configuration.</td>
      <td></td>
    </tr>
    <tr>
      <td>`defaultRuntimeSeccompProfileEnabled`</td>
      <td>bool</td>
      <td>Enable container runtime default Seccomp profile.</td>
      <td>`true`<br />`yes`<br />`false`<br />`no`<br /></td>
    </tr>
    <tr>
      <td>`registerWithFQDN`</td>
      <td>bool</td>
      <td>The `registerWithFQDN` field is used to force kubelet to use the node FQDN for registration.<br />This is required in clouds like AWS.</td>
      <td>`true`<br />`yes`<br />`false`<br />`no`<br /></td>
    </tr>
    <tr>
      <td>`nodeIP`</td>
      <td><a href="#nodeIP">KubeletNodeIPConfig</a></td>
      <td>The `nodeIP` field is used to configure `--node-ip` flag for the kubelet.<br />This is used when a node has multiple addresses to choose from.</td>
      <td></td>
    </tr>
    <tr>
      <td>`skipNodeRegistration`</td>
      <td>bool</td>
      <td>The `skipNodeRegistration` is used to run the kubelet without registering with the apiserver.<br />This runs kubelet as standalone and only runs static pods.</td>
      <td>`true`<br />`yes`<br />`false`<br />`no`<br /></td>
    </tr>
    <tr>
      <td>`disableManifestsDirectory`</td>
      <td>bool</td>
      <td>The `disableManifestsDirectory` field configures the kubelet to get static pod manifests from the /etc/kubernetes/manifests directory.<br />It's recommended to configure static pods with the "pods" key instead.</td>
      <td>`true`<br />`yes`<br />`false`<br />`no`<br /></td>
    </tr>
  </tbody>
</table>



#### extraMounts[]

ExtraMount wraps OCI Mount specification.



```yaml
machine:
    kubelet:
        extraMounts:
            - destination: /var/lib/example # Destination is the absolute path where the mount will be placed in the container.
              type: bind # Type specifies the mount kind.
              source: /var/lib/example # Source specifies the source path of the mount.
              # Options are fstab style mount options.
              options:
                - bind
                - rshared
                - rw
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`destination`</td>
      <td>string</td>
      <td>Destination is the absolute path where the mount will be placed in the container.</td>
      <td></td>
    </tr>
    <tr>
      <td>`type`</td>
      <td>string</td>
      <td>Type specifies the mount kind.</td>
      <td></td>
    </tr>
    <tr>
      <td>`source`</td>
      <td>string</td>
      <td>Source specifies the source path of the mount.</td>
      <td></td>
    </tr>
    <tr>
      <td>`options`</td>
      <td>[]string</td>
      <td>Options are fstab style mount options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`uidMappings`</td>
      <td><a href="#uidMappings.">[]LinuxIDMapping</a></td>
      <td>UID/GID mappings used for changing file owners w/o calling chown, fs should support it.<br /><br />Every mount point could have its own mapping.</td>
      <td></td>
    </tr>
    <tr>
      <td>`gidMappings`</td>
      <td><a href="#gidMappings.">[]LinuxIDMapping</a></td>
      <td>UID/GID mappings used for changing file owners w/o calling chown, fs should support it.<br /><br />Every mount point could have its own mapping.</td>
      <td></td>
    </tr>
  </tbody>
</table>



##### uidMappings[]

LinuxIDMapping represents the Linux ID mapping.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`containerID`</td>
      <td>uint32</td>
      <td>ContainerID is the starting UID/GID in the container.</td>
      <td></td>
    </tr>
    <tr>
      <td>`hostID`</td>
      <td>uint32</td>
      <td>HostID is the starting UID/GID on the host to be mapped to 'ContainerID'.</td>
      <td></td>
    </tr>
    <tr>
      <td>`size`</td>
      <td>uint32</td>
      <td>Size is the number of IDs to be mapped.</td>
      <td></td>
    </tr>
  </tbody>
</table>





##### gidMappings[]

LinuxIDMapping represents the Linux ID mapping.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`containerID`</td>
      <td>uint32</td>
      <td>ContainerID is the starting UID/GID in the container.</td>
      <td></td>
    </tr>
    <tr>
      <td>`hostID`</td>
      <td>uint32</td>
      <td>HostID is the starting UID/GID on the host to be mapped to 'ContainerID'.</td>
      <td></td>
    </tr>
    <tr>
      <td>`size`</td>
      <td>uint32</td>
      <td>Size is the number of IDs to be mapped.</td>
      <td></td>
    </tr>
  </tbody>
</table>







#### nodeIP

KubeletNodeIPConfig represents the kubelet node IP configuration.



```yaml
machine:
    kubelet:
        nodeIP:
            # The `validSubnets` field configures the networks to pick kubelet node IP from.
            validSubnets:
                - 10.0.0.0/8
                - '!10.0.0.3/32'
                - fdc7::/16
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`validSubnets`</td>
      <td>[]string</td>
      <td>The `validSubnets` field configures the networks to pick kubelet node IP from.<br />For dual stack configuration, there should be two subnets: one for IPv4, another for IPv6.<br />IPs can be excluded from the list by using negative match with `!`, e.g `!10.0.0.0/8`.<br />Negative subnet matches should be specified last to filter out IPs picked by positive matches.<br />If not specified, node IP is picked based on cluster podCIDRs: IPv4/IPv6 address or both.</td>
      <td></td>
    </tr>
  </tbody>
</table>







### network

NetworkConfig represents the machine's networking config values.



```yaml
machine:
    network:
        # `interfaces` is used to define the network interface configuration.
        interfaces:
            - interface: enp0s1 # The interface name.
              # Assigns static IP addresses to the interface.
              addresses:
                - 192.168.2.0/24
              # A list of routes associated with the interface.
              routes:
                - network: 0.0.0.0/0 # The route's network (destination).
                  gateway: 192.168.2.1 # The route's gateway (if empty, creates link scope route).
                  metric: 1024 # The optional metric for the route.
              mtu: 1500 # The interface's MTU.

              # # Picks a network device using the selector.

              # # select a device with bus prefix 00:*.
              # deviceSelector:
              #     busPath: 00:* # PCI, USB bus prefix, supports matching by wildcard.
              # # select a device with mac address matching `*:f0:ab` and `virtio` kernel driver.
              # deviceSelector:
              #     hardwareAddr: '*:f0:ab' # Device hardware (MAC) address, supports matching by wildcard.
              #     driver: virtio_net # Kernel driver, supports matching by wildcard.
              # # select a device with bus prefix 00:*, a device with mac address matching `*:f0:ab` and `virtio` kernel driver.
              # deviceSelector:
              #     - busPath: 00:* # PCI, USB bus prefix, supports matching by wildcard.
              #     - hardwareAddr: '*:f0:ab' # Device hardware (MAC) address, supports matching by wildcard.
              #       driver: virtio_net # Kernel driver, supports matching by wildcard.

              # # Bond specific options.
              # bond:
              #     # The interfaces that make up the bond.
              #     interfaces:
              #         - enp2s0
              #         - enp2s1
              #     # Picks a network device using the selector.
              #     deviceSelectors:
              #         - busPath: 00:* # PCI, USB bus prefix, supports matching by wildcard.
              #         - hardwareAddr: '*:f0:ab' # Device hardware (MAC) address, supports matching by wildcard.
              #           driver: virtio_net # Kernel driver, supports matching by wildcard.
              #     mode: 802.3ad # A bond option.
              #     lacpRate: fast # A bond option.

              # # Bridge specific options.
              # bridge:
              #     # The interfaces that make up the bridge.
              #     interfaces:
              #         - enxda4042ca9a51
              #         - enxae2a6774c259
              #     # Enable STP on this bridge.
              #     stp:
              #         enabled: true # Whether Spanning Tree Protocol (STP) is enabled.

              # # Configure this device as a bridge port.
              # bridgePort:
              #     master: br0 # The name of the bridge master interface

              # # Indicates if DHCP should be used to configure the interface.
              # dhcp: true

              # # DHCP specific options.
              # dhcpOptions:
              #     routeMetric: 1024 # The priority of all routes received via DHCP.

              # # Wireguard specific configuration.

              # # wireguard server example
              # wireguard:
              #     privateKey: ABCDEF... # Specifies a private key configuration (base64 encoded).
              #     listenPort: 51111 # Specifies a device's listening port.
              #     # Specifies a list of peer configurations to apply to a device.
              #     peers:
              #         - publicKey: ABCDEF... # Specifies the public key of this peer.
              #           endpoint: 192.168.1.3 # Specifies the endpoint of this peer entry.
              #           # AllowedIPs specifies a list of allowed IP addresses in CIDR notation for this peer.
              #           allowedIPs:
              #             - 192.168.1.0/24
              # # wireguard peer example
              # wireguard:
              #     privateKey: ABCDEF... # Specifies a private key configuration (base64 encoded).
              #     # Specifies a list of peer configurations to apply to a device.
              #     peers:
              #         - publicKey: ABCDEF... # Specifies the public key of this peer.
              #           endpoint: 192.168.1.2:51822 # Specifies the endpoint of this peer entry.
              #           persistentKeepaliveInterval: 10s # Specifies the persistent keepalive interval for this peer.
              #           # AllowedIPs specifies a list of allowed IP addresses in CIDR notation for this peer.
              #           allowedIPs:
              #             - 192.168.1.0/24

              # # Virtual (shared) IP address configuration.

              # # layer2 vip example
              # vip:
              #     ip: 172.16.199.55 # Specifies the IP address to be used.
        # Used to statically set the nameservers for the machine.
        nameservers:
            - 9.8.7.6
            - 8.7.6.5
        # Used to statically set arbitrary search domains.
        searchDomains:
            - example.org
            - example.com

        # # Configures KubeSpan feature.
        # kubespan:
        #     enabled: true # Enable the KubeSpan feature.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`interfaces`</td>
      <td><a href="#interfaces.">[]Device</a></td>
      <td>`interfaces` is used to define the network interface configuration.<br />By default all network interfaces will attempt a DHCP discovery.<br />This can be further tuned through this configuration parameter.</td>
      <td></td>
    </tr>
    <tr>
      <td>`nameservers`</td>
      <td>[]string</td>
      <td>Used to statically set the nameservers for the machine.<br />Defaults to `1.1.1.1` and `8.8.8.8`</td>
      <td></td>
    </tr>
    <tr>
      <td>`searchDomains`</td>
      <td>[]string</td>
      <td>Used to statically set arbitrary search domains.</td>
      <td></td>
    </tr>
    <tr>
      <td>`kubespan`</td>
      <td><a href="#kubespan">NetworkKubeSpan</a></td>
      <td>Configures KubeSpan feature.</td>
      <td></td>
    </tr>
    <tr>
      <td>`disableSearchDomain`</td>
      <td>bool</td>
      <td>Disable generating a default search domain in /etc/resolv.conf<br />based on the machine hostname.<br />Defaults to `false`.</td>
      <td>`true`<br />`yes`<br />`false`<br />`no`<br /></td>
    </tr>
  </tbody>
</table>



#### interfaces[]

Device represents a network interface.



```yaml
machine:
    network:
        interfaces:
            - interface: enp0s1 # The interface name.
              # Assigns static IP addresses to the interface.
              addresses:
                - 192.168.2.0/24
              # A list of routes associated with the interface.
              routes:
                - network: 0.0.0.0/0 # The route's network (destination).
                  gateway: 192.168.2.1 # The route's gateway (if empty, creates link scope route).
                  metric: 1024 # The optional metric for the route.
              mtu: 1500 # The interface's MTU.

              # # Picks a network device using the selector.

              # # select a device with bus prefix 00:*.
              # deviceSelector:
              #     busPath: 00:* # PCI, USB bus prefix, supports matching by wildcard.
              # # select a device with mac address matching `*:f0:ab` and `virtio` kernel driver.
              # deviceSelector:
              #     hardwareAddr: '*:f0:ab' # Device hardware (MAC) address, supports matching by wildcard.
              #     driver: virtio_net # Kernel driver, supports matching by wildcard.
              # # select a device with bus prefix 00:*, a device with mac address matching `*:f0:ab` and `virtio` kernel driver.
              # deviceSelector:
              #     - busPath: 00:* # PCI, USB bus prefix, supports matching by wildcard.
              #     - hardwareAddr: '*:f0:ab' # Device hardware (MAC) address, supports matching by wildcard.
              #       driver: virtio_net # Kernel driver, supports matching by wildcard.

              # # Bond specific options.
              # bond:
              #     # The interfaces that make up the bond.
              #     interfaces:
              #         - enp2s0
              #         - enp2s1
              #     # Picks a network device using the selector.
              #     deviceSelectors:
              #         - busPath: 00:* # PCI, USB bus prefix, supports matching by wildcard.
              #         - hardwareAddr: '*:f0:ab' # Device hardware (MAC) address, supports matching by wildcard.
              #           driver: virtio_net # Kernel driver, supports matching by wildcard.
              #     mode: 802.3ad # A bond option.
              #     lacpRate: fast # A bond option.

              # # Bridge specific options.
              # bridge:
              #     # The interfaces that make up the bridge.
              #     interfaces:
              #         - enxda4042ca9a51
              #         - enxae2a6774c259
              #     # Enable STP on this bridge.
              #     stp:
              #         enabled: true # Whether Spanning Tree Protocol (STP) is enabled.

              # # Configure this device as a bridge port.
              # bridgePort:
              #     master: br0 # The name of the bridge master interface

              # # Indicates if DHCP should be used to configure the interface.
              # dhcp: true

              # # DHCP specific options.
              # dhcpOptions:
              #     routeMetric: 1024 # The priority of all routes received via DHCP.

              # # Wireguard specific configuration.

              # # wireguard server example
              # wireguard:
              #     privateKey: ABCDEF... # Specifies a private key configuration (base64 encoded).
              #     listenPort: 51111 # Specifies a device's listening port.
              #     # Specifies a list of peer configurations to apply to a device.
              #     peers:
              #         - publicKey: ABCDEF... # Specifies the public key of this peer.
              #           endpoint: 192.168.1.3 # Specifies the endpoint of this peer entry.
              #           # AllowedIPs specifies a list of allowed IP addresses in CIDR notation for this peer.
              #           allowedIPs:
              #             - 192.168.1.0/24
              # # wireguard peer example
              # wireguard:
              #     privateKey: ABCDEF... # Specifies a private key configuration (base64 encoded).
              #     # Specifies a list of peer configurations to apply to a device.
              #     peers:
              #         - publicKey: ABCDEF... # Specifies the public key of this peer.
              #           endpoint: 192.168.1.2:51822 # Specifies the endpoint of this peer entry.
              #           persistentKeepaliveInterval: 10s # Specifies the persistent keepalive interval for this peer.
              #           # AllowedIPs specifies a list of allowed IP addresses in CIDR notation for this peer.
              #           allowedIPs:
              #             - 192.168.1.0/24

              # # Virtual (shared) IP address configuration.

              # # layer2 vip example
              # vip:
              #     ip: 172.16.199.55 # Specifies the IP address to be used.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`interface`</td>
      <td>string</td>
      <td>The interface name.<br />Mutually exclusive with `deviceSelector`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`deviceSelector`</td>
      <td><a href="#deviceSelector">NetworkDeviceSelector</a></td>
      <td>Picks a network device using the selector.<br />Mutually exclusive with `interface`.<br />Supports partial match using wildcard syntax.</td>
      <td></td>
    </tr>
    <tr>
      <td>`addresses`</td>
      <td>[]string</td>
      <td>Assigns static IP addresses to the interface.<br />An address can be specified either in proper CIDR notation or as a standalone address (netmask of all ones is assumed).</td>
      <td></td>
    </tr>
    <tr>
      <td>`routes`</td>
      <td><a href="#routes.">[]Route</a></td>
      <td>A list of routes associated with the interface.<br />If used in combination with DHCP, these routes will be appended to routes returned by DHCP server.</td>
      <td></td>
    </tr>
    <tr>
      <td>`bond`</td>
      <td><a href="#bond">Bond</a></td>
      <td>Bond specific options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`bridge`</td>
      <td><a href="#bridge">Bridge</a></td>
      <td>Bridge specific options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`bridgePort`</td>
      <td><a href="#bridgePort">BridgePort</a></td>
      <td>Configure this device as a bridge port.<br />This can be used to dynamically assign network interfaces to a bridge.</td>
      <td></td>
    </tr>
    <tr>
      <td>`vlans`</td>
      <td><a href="#vlans.">[]Vlan</a></td>
      <td>VLAN specific options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`mtu`</td>
      <td>int</td>
      <td>The interface's MTU.<br />If used in combination with DHCP, this will override any MTU settings returned from DHCP server.</td>
      <td></td>
    </tr>
    <tr>
      <td>`dhcp`</td>
      <td>bool</td>
      <td>Indicates if DHCP should be used to configure the interface.<br />The following DHCP options are supported:<br /><br />- `OptionClasslessStaticRoute`<br />- `OptionDomainNameServer`<br />- `OptionDNSDomainSearchList`<br />- `OptionHostName`</td>
      <td></td>
    </tr>
    <tr>
      <td>`ignore`</td>
      <td>bool</td>
      <td>Indicates if the interface should be ignored (skips configuration).</td>
      <td></td>
    </tr>
    <tr>
      <td>`dummy`</td>
      <td>bool</td>
      <td>Indicates if the interface is a dummy interface.<br />`dummy` is used to specify that this interface should be a virtual-only, dummy interface.</td>
      <td></td>
    </tr>
    <tr>
      <td>`dhcpOptions`</td>
      <td><a href="#dhcpOptions">DHCPOptions</a></td>
      <td>DHCP specific options.<br />`dhcp` *must* be set to true for these to take effect.</td>
      <td></td>
    </tr>
    <tr>
      <td>`wireguard`</td>
      <td><a href="#wireguard">DeviceWireguardConfig</a></td>
      <td>Wireguard specific configuration.<br />Includes things like private key, listen port, peers.</td>
      <td></td>
    </tr>
    <tr>
      <td>`vip`</td>
      <td><a href="#vip">DeviceVIPConfig</a></td>
      <td>Virtual (shared) IP address configuration.</td>
      <td></td>
    </tr>
  </tbody>
</table>



##### deviceSelector

NetworkDeviceSelector struct describes network device selector.



```yaml
machine:
    network:
        interfaces:
            - deviceSelector:
                busPath: 00:* # PCI, USB bus prefix, supports matching by wildcard.
```

```yaml
machine:
    network:
        interfaces:
            - deviceSelector:
                hardwareAddr: '*:f0:ab' # Device hardware (MAC) address, supports matching by wildcard.
                driver: virtio_net # Kernel driver, supports matching by wildcard.
```

```yaml
machine:
    network:
        interfaces:
            - deviceSelector:
                - busPath: 00:* # PCI, USB bus prefix, supports matching by wildcard.
                - hardwareAddr: '*:f0:ab' # Device hardware (MAC) address, supports matching by wildcard.
                  driver: virtio_net # Kernel driver, supports matching by wildcard.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`busPath`</td>
      <td>string</td>
      <td>PCI, USB bus prefix, supports matching by wildcard.</td>
      <td></td>
    </tr>
    <tr>
      <td>`hardwareAddr`</td>
      <td>string</td>
      <td>Device hardware (MAC) address, supports matching by wildcard.</td>
      <td></td>
    </tr>
    <tr>
      <td>`permanentAddr`</td>
      <td>string</td>
      <td>Device permanent hardware address, supports matching by wildcard.<br />The permanent address doesn't change when the link is enslaved to a bond,<br />so it's recommended to use this field for bond members.</td>
      <td></td>
    </tr>
    <tr>
      <td>`pciID`</td>
      <td>string</td>
      <td>PCI ID (vendor ID, product ID), supports matching by wildcard.</td>
      <td></td>
    </tr>
    <tr>
      <td>`driver`</td>
      <td>string</td>
      <td>Kernel driver, supports matching by wildcard.</td>
      <td></td>
    </tr>
    <tr>
      <td>`physical`</td>
      <td>bool</td>
      <td>Select only physical devices.</td>
      <td></td>
    </tr>
  </tbody>
</table>





##### routes[]

Route represents a network route.



```yaml
machine:
    network:
        interfaces:
            - routes:
                - network: 0.0.0.0/0 # The route's network (destination).
                  gateway: 10.5.0.1 # The route's gateway (if empty, creates link scope route).
                - network: 10.2.0.0/16 # The route's network (destination).
                  gateway: 10.2.0.1 # The route's gateway (if empty, creates link scope route).
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`network`</td>
      <td>string</td>
      <td>The route's network (destination).</td>
      <td></td>
    </tr>
    <tr>
      <td>`gateway`</td>
      <td>string</td>
      <td>The route's gateway (if empty, creates link scope route).</td>
      <td></td>
    </tr>
    <tr>
      <td>`source`</td>
      <td>string</td>
      <td>The route's source address (optional).</td>
      <td></td>
    </tr>
    <tr>
      <td>`metric`</td>
      <td>uint32</td>
      <td>The optional metric for the route.</td>
      <td></td>
    </tr>
    <tr>
      <td>`mtu`</td>
      <td>uint32</td>
      <td>The optional MTU for the route.</td>
      <td></td>
    </tr>
  </tbody>
</table>





##### bond

Bond contains the various options for configuring a bonded interface.



```yaml
machine:
    network:
        interfaces:
            - bond:
                # The interfaces that make up the bond.
                interfaces:
                    - enp2s0
                    - enp2s1
                mode: 802.3ad # A bond option.
                lacpRate: fast # A bond option.

                # # Picks a network device using the selector.

                # # select a device with bus prefix 00:*, a device with mac address matching `*:f0:ab` and `virtio` kernel driver.
                # deviceSelectors:
                #     - busPath: 00:* # PCI, USB bus prefix, supports matching by wildcard.
                #     - hardwareAddr: '*:f0:ab' # Device hardware (MAC) address, supports matching by wildcard.
                #       driver: virtio_net # Kernel driver, supports matching by wildcard.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`interfaces`</td>
      <td>[]string</td>
      <td>The interfaces that make up the bond.</td>
      <td></td>
    </tr>
    <tr>
      <td>`deviceSelectors`</td>
      <td><a href="#deviceSelectors.">[]NetworkDeviceSelector</a></td>
      <td>Picks a network device using the selector.<br />Mutually exclusive with `interfaces`.<br />Supports partial match using wildcard syntax.</td>
      <td></td>
    </tr>
    <tr>
      <td>`arpIPTarget`</td>
      <td>[]string</td>
      <td>A bond option.<br />Please see the official kernel documentation.<br />Not supported at the moment.</td>
      <td></td>
    </tr>
    <tr>
      <td>`mode`</td>
      <td>string</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`xmitHashPolicy`</td>
      <td>string</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`lacpRate`</td>
      <td>string</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`adActorSystem`</td>
      <td>string</td>
      <td>A bond option.<br />Please see the official kernel documentation.<br />Not supported at the moment.</td>
      <td></td>
    </tr>
    <tr>
      <td>`arpValidate`</td>
      <td>string</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`arpAllTargets`</td>
      <td>string</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`primary`</td>
      <td>string</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`primaryReselect`</td>
      <td>string</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`failOverMac`</td>
      <td>string</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`adSelect`</td>
      <td>string</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`miimon`</td>
      <td>uint32</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`updelay`</td>
      <td>uint32</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`downdelay`</td>
      <td>uint32</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`arpInterval`</td>
      <td>uint32</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`resendIgmp`</td>
      <td>uint32</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`minLinks`</td>
      <td>uint32</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`lpInterval`</td>
      <td>uint32</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`packetsPerSlave`</td>
      <td>uint32</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`numPeerNotif`</td>
      <td>uint8</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`tlbDynamicLb`</td>
      <td>uint8</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`allSlavesActive`</td>
      <td>uint8</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`useCarrier`</td>
      <td>bool</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`adActorSysPrio`</td>
      <td>uint16</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`adUserPortKey`</td>
      <td>uint16</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`peerNotifyDelay`</td>
      <td>uint32</td>
      <td>A bond option.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
  </tbody>
</table>



###### deviceSelectors[]

NetworkDeviceSelector struct describes network device selector.



```yaml
machine:
    network:
        interfaces:
            - bond:
                deviceSelectors:
                    busPath: 00:* # PCI, USB bus prefix, supports matching by wildcard.
```

```yaml
machine:
    network:
        interfaces:
            - bond:
                deviceSelectors:
                    hardwareAddr: '*:f0:ab' # Device hardware (MAC) address, supports matching by wildcard.
                    driver: virtio_net # Kernel driver, supports matching by wildcard.
```

```yaml
machine:
    network:
        interfaces:
            - bond:
                deviceSelectors:
                    - busPath: 00:* # PCI, USB bus prefix, supports matching by wildcard.
                    - hardwareAddr: '*:f0:ab' # Device hardware (MAC) address, supports matching by wildcard.
                      driver: virtio_net # Kernel driver, supports matching by wildcard.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`busPath`</td>
      <td>string</td>
      <td>PCI, USB bus prefix, supports matching by wildcard.</td>
      <td></td>
    </tr>
    <tr>
      <td>`hardwareAddr`</td>
      <td>string</td>
      <td>Device hardware (MAC) address, supports matching by wildcard.</td>
      <td></td>
    </tr>
    <tr>
      <td>`permanentAddr`</td>
      <td>string</td>
      <td>Device permanent hardware address, supports matching by wildcard.<br />The permanent address doesn't change when the link is enslaved to a bond,<br />so it's recommended to use this field for bond members.</td>
      <td></td>
    </tr>
    <tr>
      <td>`pciID`</td>
      <td>string</td>
      <td>PCI ID (vendor ID, product ID), supports matching by wildcard.</td>
      <td></td>
    </tr>
    <tr>
      <td>`driver`</td>
      <td>string</td>
      <td>Kernel driver, supports matching by wildcard.</td>
      <td></td>
    </tr>
    <tr>
      <td>`physical`</td>
      <td>bool</td>
      <td>Select only physical devices.</td>
      <td></td>
    </tr>
  </tbody>
</table>







##### bridge

Bridge contains the various options for configuring a bridge interface.



```yaml
machine:
    network:
        interfaces:
            - bridge:
                # The interfaces that make up the bridge.
                interfaces:
                    - enxda4042ca9a51
                    - enxae2a6774c259
                # Enable STP on this bridge.
                stp:
                    enabled: true # Whether Spanning Tree Protocol (STP) is enabled.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`interfaces`</td>
      <td>[]string</td>
      <td>The interfaces that make up the bridge.</td>
      <td></td>
    </tr>
    <tr>
      <td>`stp`</td>
      <td><a href="#stp">STP</a></td>
      <td>Enable STP on this bridge.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`vlan`</td>
      <td><a href="#vlan">BridgeVLAN</a></td>
      <td>Enable VLAN-awareness on this bridge.<br />Please see the official kernel documentation.</td>
      <td></td>
    </tr>
  </tbody>
</table>



###### stp

STP contains the various options for configuring the STP properties of a bridge interface.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`enabled`</td>
      <td>bool</td>
      <td>Whether Spanning Tree Protocol (STP) is enabled.</td>
      <td></td>
    </tr>
  </tbody>
</table>





###### vlan

BridgeVLAN contains the various options for configuring the VLAN properties of a bridge interface.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`vlanFiltering`</td>
      <td>bool</td>
      <td>Whether VLAN filtering is enabled.</td>
      <td></td>
    </tr>
  </tbody>
</table>







##### bridgePort

BridgePort contains settings for assigning a link to a bridge interface.



```yaml
machine:
    network:
        interfaces:
            - bridgePort:
                master: br0 # The name of the bridge master interface
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`master`</td>
      <td>string</td>
      <td>The name of the bridge master interface</td>
      <td></td>
    </tr>
  </tbody>
</table>





##### vlans[]

Vlan represents vlan settings for a device.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`addresses`</td>
      <td>[]string</td>
      <td>The addresses in CIDR notation or as plain IPs to use.</td>
      <td></td>
    </tr>
    <tr>
      <td>`routes`</td>
      <td><a href="#routes.">[]Route</a></td>
      <td>A list of routes associated with the VLAN.</td>
      <td></td>
    </tr>
    <tr>
      <td>`dhcp`</td>
      <td>bool</td>
      <td>Indicates if DHCP should be used.</td>
      <td></td>
    </tr>
    <tr>
      <td>`vlanId`</td>
      <td>uint16</td>
      <td>The VLAN's ID.</td>
      <td></td>
    </tr>
    <tr>
      <td>`mtu`</td>
      <td>uint32</td>
      <td>The VLAN's MTU.</td>
      <td></td>
    </tr>
    <tr>
      <td>`vip`</td>
      <td><a href="#vip">DeviceVIPConfig</a></td>
      <td>The VLAN's virtual IP address configuration.</td>
      <td></td>
    </tr>
    <tr>
      <td>`dhcpOptions`</td>
      <td><a href="#dhcpOptions">DHCPOptions</a></td>
      <td>DHCP specific options.<br />`dhcp` *must* be set to true for these to take effect.</td>
      <td></td>
    </tr>
  </tbody>
</table>



###### routes[]

Route represents a network route.



```yaml
machine:
    network:
        interfaces:
            - vlans:
                - routes:
                    - network: 0.0.0.0/0 # The route's network (destination).
                      gateway: 10.5.0.1 # The route's gateway (if empty, creates link scope route).
                    - network: 10.2.0.0/16 # The route's network (destination).
                      gateway: 10.2.0.1 # The route's gateway (if empty, creates link scope route).
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`network`</td>
      <td>string</td>
      <td>The route's network (destination).</td>
      <td></td>
    </tr>
    <tr>
      <td>`gateway`</td>
      <td>string</td>
      <td>The route's gateway (if empty, creates link scope route).</td>
      <td></td>
    </tr>
    <tr>
      <td>`source`</td>
      <td>string</td>
      <td>The route's source address (optional).</td>
      <td></td>
    </tr>
    <tr>
      <td>`metric`</td>
      <td>uint32</td>
      <td>The optional metric for the route.</td>
      <td></td>
    </tr>
    <tr>
      <td>`mtu`</td>
      <td>uint32</td>
      <td>The optional MTU for the route.</td>
      <td></td>
    </tr>
  </tbody>
</table>





###### vip

DeviceVIPConfig contains settings for configuring a Virtual Shared IP on an interface.



```yaml
machine:
    network:
        interfaces:
            - vlans:
                - vip:
                    ip: 172.16.199.55 # Specifies the IP address to be used.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`ip`</td>
      <td>string</td>
      <td>Specifies the IP address to be used.</td>
      <td></td>
    </tr>
    <tr>
      <td>`equinixMetal`</td>
      <td><a href="#equinixMetal">VIPEquinixMetalConfig</a></td>
      <td>Specifies the Equinix Metal API settings to assign VIP to the node.</td>
      <td></td>
    </tr>
    <tr>
      <td>`hcloud`</td>
      <td><a href="#hcloud">VIPHCloudConfig</a></td>
      <td>Specifies the Hetzner Cloud API settings to assign VIP to the node.</td>
      <td></td>
    </tr>
  </tbody>
</table>



###### equinixMetal

VIPEquinixMetalConfig contains settings for Equinix Metal VIP management.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`apiToken`</td>
      <td>string</td>
      <td>Specifies the Equinix Metal API Token.</td>
      <td></td>
    </tr>
  </tbody>
</table>





###### hcloud

VIPHCloudConfig contains settings for Hetzner Cloud VIP management.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`apiToken`</td>
      <td>string</td>
      <td>Specifies the Hetzner Cloud API Token.</td>
      <td></td>
    </tr>
  </tbody>
</table>







###### dhcpOptions

DHCPOptions contains options for configuring the DHCP settings for a given interface.



```yaml
machine:
    network:
        interfaces:
            - vlans:
                - dhcpOptions:
                    routeMetric: 1024 # The priority of all routes received via DHCP.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`routeMetric`</td>
      <td>uint32</td>
      <td>The priority of all routes received via DHCP.</td>
      <td></td>
    </tr>
    <tr>
      <td>`ipv4`</td>
      <td>bool</td>
      <td>Enables DHCPv4 protocol for the interface (default is enabled).</td>
      <td></td>
    </tr>
    <tr>
      <td>`ipv6`</td>
      <td>bool</td>
      <td>Enables DHCPv6 protocol for the interface (default is disabled).</td>
      <td></td>
    </tr>
    <tr>
      <td>`duidv6`</td>
      <td>string</td>
      <td>Set client DUID (hex string).</td>
      <td></td>
    </tr>
  </tbody>
</table>







##### dhcpOptions

DHCPOptions contains options for configuring the DHCP settings for a given interface.



```yaml
machine:
    network:
        interfaces:
            - dhcpOptions:
                routeMetric: 1024 # The priority of all routes received via DHCP.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`routeMetric`</td>
      <td>uint32</td>
      <td>The priority of all routes received via DHCP.</td>
      <td></td>
    </tr>
    <tr>
      <td>`ipv4`</td>
      <td>bool</td>
      <td>Enables DHCPv4 protocol for the interface (default is enabled).</td>
      <td></td>
    </tr>
    <tr>
      <td>`ipv6`</td>
      <td>bool</td>
      <td>Enables DHCPv6 protocol for the interface (default is disabled).</td>
      <td></td>
    </tr>
    <tr>
      <td>`duidv6`</td>
      <td>string</td>
      <td>Set client DUID (hex string).</td>
      <td></td>
    </tr>
  </tbody>
</table>





##### wireguard

DeviceWireguardConfig contains settings for configuring Wireguard network interface.



```yaml
machine:
    network:
        interfaces:
            - wireguard:
                privateKey: ABCDEF... # Specifies a private key configuration (base64 encoded).
                listenPort: 51111 # Specifies a device's listening port.
                # Specifies a list of peer configurations to apply to a device.
                peers:
                    - publicKey: ABCDEF... # Specifies the public key of this peer.
                      endpoint: 192.168.1.3 # Specifies the endpoint of this peer entry.
                      # AllowedIPs specifies a list of allowed IP addresses in CIDR notation for this peer.
                      allowedIPs:
                        - 192.168.1.0/24
```

```yaml
machine:
    network:
        interfaces:
            - wireguard:
                privateKey: ABCDEF... # Specifies a private key configuration (base64 encoded).
                # Specifies a list of peer configurations to apply to a device.
                peers:
                    - publicKey: ABCDEF... # Specifies the public key of this peer.
                      endpoint: 192.168.1.2:51822 # Specifies the endpoint of this peer entry.
                      persistentKeepaliveInterval: 10s # Specifies the persistent keepalive interval for this peer.
                      # AllowedIPs specifies a list of allowed IP addresses in CIDR notation for this peer.
                      allowedIPs:
                        - 192.168.1.0/24
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`privateKey`</td>
      <td>string</td>
      <td>Specifies a private key configuration (base64 encoded).<br />Can be generated by `wg genkey`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`listenPort`</td>
      <td>int</td>
      <td>Specifies a device's listening port.</td>
      <td></td>
    </tr>
    <tr>
      <td>`firewallMark`</td>
      <td>int</td>
      <td>Specifies a device's firewall mark.</td>
      <td></td>
    </tr>
    <tr>
      <td>`peers`</td>
      <td><a href="#peers.">[]DeviceWireguardPeer</a></td>
      <td>Specifies a list of peer configurations to apply to a device.</td>
      <td></td>
    </tr>
  </tbody>
</table>



###### peers[]

DeviceWireguardPeer a WireGuard device peer configuration.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`publicKey`</td>
      <td>string</td>
      <td>Specifies the public key of this peer.<br />Can be extracted from private key by running `wg pubkey {"<"} private.key {">"} public.key && cat public.key`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`endpoint`</td>
      <td>string</td>
      <td>Specifies the endpoint of this peer entry.</td>
      <td></td>
    </tr>
    <tr>
      <td>`persistentKeepaliveInterval`</td>
      <td>Duration</td>
      <td>Specifies the persistent keepalive interval for this peer.<br />Field format accepts any Go time.Duration format ('1h' for one hour, '10m' for ten minutes).</td>
      <td></td>
    </tr>
    <tr>
      <td>`allowedIPs`</td>
      <td>[]string</td>
      <td>AllowedIPs specifies a list of allowed IP addresses in CIDR notation for this peer.</td>
      <td></td>
    </tr>
  </tbody>
</table>







##### vip

DeviceVIPConfig contains settings for configuring a Virtual Shared IP on an interface.



```yaml
machine:
    network:
        interfaces:
            - vip:
                ip: 172.16.199.55 # Specifies the IP address to be used.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`ip`</td>
      <td>string</td>
      <td>Specifies the IP address to be used.</td>
      <td></td>
    </tr>
    <tr>
      <td>`equinixMetal`</td>
      <td><a href="#equinixMetal">VIPEquinixMetalConfig</a></td>
      <td>Specifies the Equinix Metal API settings to assign VIP to the node.</td>
      <td></td>
    </tr>
    <tr>
      <td>`hcloud`</td>
      <td><a href="#hcloud">VIPHCloudConfig</a></td>
      <td>Specifies the Hetzner Cloud API settings to assign VIP to the node.</td>
      <td></td>
    </tr>
  </tbody>
</table>



###### equinixMetal

VIPEquinixMetalConfig contains settings for Equinix Metal VIP management.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`apiToken`</td>
      <td>string</td>
      <td>Specifies the Equinix Metal API Token.</td>
      <td></td>
    </tr>
  </tbody>
</table>





###### hcloud

VIPHCloudConfig contains settings for Hetzner Cloud VIP management.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`apiToken`</td>
      <td>string</td>
      <td>Specifies the Hetzner Cloud API Token.</td>
      <td></td>
    </tr>
  </tbody>
</table>









#### kubespan

NetworkKubeSpan struct describes KubeSpan configuration.



```yaml
machine:
    network:
        kubespan:
            enabled: true # Enable the KubeSpan feature.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`enabled`</td>
      <td>bool</td>
      <td>Enable the KubeSpan feature.<br />Cluster discovery should be enabled with .cluster.discovery.enabled for KubeSpan to be enabled.</td>
      <td></td>
    </tr>
    <tr>
      <td>`advertiseKubernetesNetworks`</td>
      <td>bool</td>
      <td>Control whether Kubernetes pod CIDRs are announced over KubeSpan from the node.<br />If disabled, CNI handles encapsulating pod-to-pod traffic into some node-to-node tunnel,<br />and KubeSpan handles the node-to-node traffic.<br />If enabled, KubeSpan will take over pod-to-pod traffic and send it over KubeSpan directly.<br />When enabled, KubeSpan should have a way to detect complete pod CIDRs of the node which<br />is not always the case with CNIs not relying on Kubernetes for IPAM.</td>
      <td></td>
    </tr>
    <tr>
      <td>`allowDownPeerBypass`</td>
      <td>bool</td>
      <td>Skip sending traffic via KubeSpan if the peer connection state is not up.<br />This provides configurable choice between connectivity and security: either traffic is always<br />forced to go via KubeSpan (even if Wireguard peer connection is not up), or traffic can go directly<br />to the peer if Wireguard connection can't be established.</td>
      <td></td>
    </tr>
    <tr>
      <td>`harvestExtraEndpoints`</td>
      <td>bool</td>
      <td>KubeSpan can collect and publish extra endpoints for each member of the cluster<br />based on Wireguard endpoint information for each peer.<br />This feature is disabled by default, don't enable it<br />with high number of peers (>50) in the KubeSpan network (performance issues).</td>
      <td></td>
    </tr>
    <tr>
      <td>`mtu`</td>
      <td>uint32</td>
      <td>KubeSpan link MTU size.<br />Default value is 1420.</td>
      <td></td>
    </tr>
    <tr>
      <td>`filters`</td>
      <td><a href="#filters">KubeSpanFilters</a></td>
      <td>KubeSpan advanced filtering of network addresses .<br /><br />Settings in this section are optional, and settings apply only to the node.</td>
      <td></td>
    </tr>
  </tbody>
</table>



##### filters

KubeSpanFilters struct describes KubeSpan advanced network addresses filtering.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`endpoints`</td>
      <td>[]string</td>
      <td>Filter node addresses which will be advertised as KubeSpan endpoints for peer-to-peer Wireguard connections.<br /><br />By default, all addresses are advertised, and KubeSpan cycles through all endpoints until it finds one that works.<br /><br />Default value: no filtering.</td>
      <td></td>
    </tr>
  </tbody>
</table>









### install

InstallConfig represents the installation options for preparing a node.



```yaml
machine:
    install:
        disk: /dev/sda # The disk used for installations.
        # Allows for supplying extra kernel args via the bootloader.
        extraKernelArgs:
            - console=ttyS1
            - panic=10
        image: ghcr.io/siderolabs/installer:latest # Allows for supplying the image used to perform the installation.
        wipe: false # Indicates if the installation disk should be wiped at installation time.

        # # Look up disk using disk attributes like model, size, serial and others.
        # diskSelector:
        #     size: 4GB # Disk size.
        #     model: WDC* # Disk model `/sys/block/{"<"}dev{">"}/device/model`.
        #     busPath: /pci0000:00/0000:00:17.0/ata1/host0/target0:0:0/0:0:0:0 # Disk bus path.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`disk`</td>
      <td>string</td>
      <td>The disk used for installations.</td>
      <td></td>
    </tr>
    <tr>
      <td>`diskSelector`</td>
      <td><a href="#diskSelector">InstallDiskSelector</a></td>
      <td>Look up disk using disk attributes like model, size, serial and others.<br />Always has priority over `disk`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraKernelArgs`</td>
      <td>[]string</td>
      <td>Allows for supplying extra kernel args via the bootloader.<br />Existing kernel args can be removed by prefixing the argument with a `-`.<br />For example `-console` removes all `console={"<"}value{">"}` arguments, whereas `-console=tty0` removes the `console=tty0` default argument.<br />If Talos is using systemd-boot as a bootloader (default for UEFI) this setting will be ignored.</td>
      <td></td>
    </tr>
    <tr>
      <td>`image`</td>
      <td>string</td>
      <td>Allows for supplying the image used to perform the installation.<br />Image reference for each Talos release can be found on<br />[GitHub releases page](https://github.com/siderolabs/talos/releases).</td>
      <td></td>
    </tr>
    <tr>
      <td>`wipe`</td>
      <td>bool</td>
      <td>Indicates if the installation disk should be wiped at installation time.<br />Defaults to `true`.</td>
      <td>`true`<br />`yes`<br />`false`<br />`no`<br /></td>
    </tr>
    <tr>
      <td>`legacyBIOSSupport`</td>
      <td>bool</td>
      <td>Indicates if MBR partition should be marked as bootable (active).<br />Should be enabled only for the systems with legacy BIOS that doesn't support GPT partitioning scheme.</td>
      <td></td>
    </tr>
  </tbody>
</table>



#### diskSelector

InstallDiskSelector represents a disk query parameters for the install disk lookup.



```yaml
machine:
    install:
        diskSelector:
            size: '>= 1TB' # Disk size.
            model: WDC* # Disk model `/sys/block/{"<"}dev{">"}/device/model`.

            # # Disk bus path.
            # busPath: /pci0000:00/0000:00:17.0/ata1/host0/target0:0:0/0:0:0:0
            # busPath: /pci0000:00/*
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`size`</td>
      <td>InstallDiskSizeMatcher</td>
      <td>Disk size.</td>
      <td></td>
    </tr>
    <tr>
      <td>`name`</td>
      <td>string</td>
      <td>Disk name `/sys/block/{"<"}dev{">"}/device/name`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`model`</td>
      <td>string</td>
      <td>Disk model `/sys/block/{"<"}dev{">"}/device/model`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`serial`</td>
      <td>string</td>
      <td>Disk serial number `/sys/block/{"<"}dev{">"}/serial`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`modalias`</td>
      <td>string</td>
      <td>Disk modalias `/sys/block/{"<"}dev{">"}/device/modalias`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`uuid`</td>
      <td>string</td>
      <td>Disk UUID `/sys/block/{"<"}dev{">"}/uuid`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`wwid`</td>
      <td>string</td>
      <td>Disk WWID `/sys/block/{"<"}dev{">"}/wwid`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`type`</td>
      <td>InstallDiskType</td>
      <td>Disk Type.</td>
      <td>`ssd`<br />`hdd`<br />`nvme`<br />`sd`<br /></td>
    </tr>
    <tr>
      <td>`busPath`</td>
      <td>string</td>
      <td>Disk bus path.</td>
      <td></td>
    </tr>
  </tbody>
</table>







### files[]

MachineFile represents a file to write to disk.



```yaml
machine:
    files:
        - content: '...' # The contents of the file.
          permissions: 0o666 # The file's permissions in octal.
          path: /tmp/file.txt # The path of the file.
          op: append # The operation to use
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`content`</td>
      <td>string</td>
      <td>The contents of the file.</td>
      <td></td>
    </tr>
    <tr>
      <td>`permissions`</td>
      <td>FileMode</td>
      <td>The file's permissions in octal.</td>
      <td></td>
    </tr>
    <tr>
      <td>`path`</td>
      <td>string</td>
      <td>The path of the file.</td>
      <td></td>
    </tr>
    <tr>
      <td>`op`</td>
      <td>string</td>
      <td>The operation to use</td>
      <td>`create`<br />`append`<br />`overwrite`<br /></td>
    </tr>
  </tbody>
</table>





### time

TimeConfig represents the options for configuring time on a machine.



```yaml
machine:
    time:
        disabled: false # Indicates if the time service is disabled for the machine.
        # description: |
        servers:
            - time.cloudflare.com
        bootTimeout: 2m0s # Specifies the timeout when the node time is considered to be in sync unlocking the boot sequence.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`disabled`</td>
      <td>bool</td>
      <td>Indicates if the time service is disabled for the machine.<br />Defaults to `false`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`servers`</td>
      <td>[]string</td>
      <td>description:</td>
      <td><br /> Specifies time (NTP) servers to use for setting the system time.<br /> Defaults to `time.cloudflare.com`.<br /><br /> Talos can also sync to the PTP time source (e.g provided by the hypervisor),<br /> provide the path to the PTP device as "/dev/ptp0" or "/dev/ptp_kvm".<br /></td>
      <td></td>
    </tr>
    <tr>
      <td>`bootTimeout`</td>
      <td>Duration</td>
      <td>Specifies the timeout when the node time is considered to be in sync unlocking the boot sequence.<br />NTP sync will be still running in the background.<br />Defaults to "infinity" (waiting forever for time sync)</td>
      <td></td>
    </tr>
  </tbody>
</table>





### registries

RegistriesConfig represents the image pull options.



```yaml
machine:
    registries:
        # Specifies mirror configuration for each registry host namespace.
        mirrors:
            docker.io:
                # List of endpoints (URLs) for registry mirrors to use.
                endpoints:
                    - https://registry.local
        # Specifies TLS & auth configuration for HTTPS image registries.
        config:
            registry.local:
                # The TLS configuration for the registry.
                tls:
                    # Enable mutual TLS authentication with the registry.
                    clientIdentity:
                        crt: LS0tIEVYQU1QTEUgQ0VSVElGSUNBVEUgLS0t
                        key: LS0tIEVYQU1QTEUgS0VZIC0tLQ==
                # The auth configuration for this registry.
                auth:
                    username: username # Optional registry authentication.
                    password: password # Optional registry authentication.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`mirrors`</td>
      <td><a href="#-">map[string]RegistryMirrorConfig</a></td>
      <td>Specifies mirror configuration for each registry host namespace.<br />This setting allows to configure local pull-through caching registires,<br />air-gapped installations, etc.<br /><br />For example, when pulling an image with the reference `example.com:123/image:v1`,<br />the `example.com:123` key will be used to lookup the mirror configuration.<br /><br />Optionally the `*` key can be used to configure a fallback mirror.<br /><br />Registry name is the first segment of image identifier, with 'docker.io'<br />being default one.</td>
      <td></td>
    </tr>
    <tr>
      <td>`config`</td>
      <td><a href="#-">map[string]RegistryConfig</a></td>
      <td>Specifies TLS & auth configuration for HTTPS image registries.<br />Mutual TLS can be enabled with 'clientIdentity' option.<br /><br />The full hostname and port (if not using a default port 443)<br />should be used as the key.<br />The fallback key `*` can't be used for TLS configuration.<br /><br />TLS configuration can be skipped if registry has trusted<br />server certificate.</td>
      <td></td>
    </tr>
  </tbody>
</table>



#### mirrors.*

RegistryMirrorConfig represents mirror configuration for a registry.



```yaml
machine:
    registries:
        mirrors:
            ghcr.io:
                # List of endpoints (URLs) for registry mirrors to use.
                endpoints:
                    - https://registry.insecure
                    - https://ghcr.io/v2/
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`endpoints`</td>
      <td>[]string</td>
      <td>List of endpoints (URLs) for registry mirrors to use.<br />Endpoint configures HTTP/HTTPS access mode, host name,<br />port and path (if path is not set, it defaults to `/v2`).</td>
      <td></td>
    </tr>
    <tr>
      <td>`overridePath`</td>
      <td>bool</td>
      <td>Use the exact path specified for the endpoint (don't append /v2/).<br />This setting is often required for setting up multiple mirrors<br />on a single instance of a registry.</td>
      <td></td>
    </tr>
    <tr>
      <td>`skipFallback`</td>
      <td>bool</td>
      <td>Skip fallback to the upstream endpoint, for example the mirror configuration<br />for `docker.io` will not fallback to `registry-1.docker.io`.</td>
      <td></td>
    </tr>
  </tbody>
</table>





#### config.*

RegistryConfig specifies auth & TLS config per registry.



```yaml
machine:
    registries:
        config:
            registry.insecure:
                # The TLS configuration for the registry.
                tls:
                    insecureSkipVerify: true # Skip TLS server certificate verification (not recommended).

                    # # Enable mutual TLS authentication with the registry.
                    # clientIdentity:
                    #     crt: LS0tIEVYQU1QTEUgQ0VSVElGSUNBVEUgLS0t
                    #     key: LS0tIEVYQU1QTEUgS0VZIC0tLQ==

                # # The auth configuration for this registry.
                # auth:
                #     username: username # Optional registry authentication.
                #     password: password # Optional registry authentication.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`tls`</td>
      <td><a href="#tls">RegistryTLSConfig</a></td>
      <td>The TLS configuration for the registry.</td>
      <td></td>
    </tr>
    <tr>
      <td>`auth`</td>
      <td><a href="#auth">RegistryAuthConfig</a></td>
      <td>The auth configuration for this registry.<br />Note: changes to the registry auth will not be picked up by the CRI containerd plugin without a reboot.</td>
      <td></td>
    </tr>
  </tbody>
</table>



##### tls

RegistryTLSConfig specifies TLS config for HTTPS registries.



```yaml
machine:
    registries:
        config:
            example.com:
                tls:
                    # Enable mutual TLS authentication with the registry.
                    clientIdentity:
                        crt: LS0tIEVYQU1QTEUgQ0VSVElGSUNBVEUgLS0t
                        key: LS0tIEVYQU1QTEUgS0VZIC0tLQ==
```

```yaml
machine:
    registries:
        config:
            example.com:
                tls:
                    insecureSkipVerify: true # Skip TLS server certificate verification (not recommended).

                    # # Enable mutual TLS authentication with the registry.
                    # clientIdentity:
                    #     crt: LS0tIEVYQU1QTEUgQ0VSVElGSUNBVEUgLS0t
                    #     key: LS0tIEVYQU1QTEUgS0VZIC0tLQ==
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`clientIdentity`</td>
      <td>PEMEncodedCertificateAndKey</td>
      <td>Enable mutual TLS authentication with the registry.<br />Client certificate and key should be base64-encoded.</td>
      <td></td>
    </tr>
    <tr>
      <td>`ca`</td>
      <td>Base64Bytes</td>
      <td>CA registry certificate to add the list of trusted certificates.<br />Certificate should be base64-encoded.</td>
      <td></td>
    </tr>
    <tr>
      <td>`insecureSkipVerify`</td>
      <td>bool</td>
      <td>Skip TLS server certificate verification (not recommended).</td>
      <td></td>
    </tr>
  </tbody>
</table>





##### auth

RegistryAuthConfig specifies authentication configuration for a registry.



```yaml
machine:
    registries:
        config:
            example.com:
                auth:
                    username: username # Optional registry authentication.
                    password: password # Optional registry authentication.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`username`</td>
      <td>string</td>
      <td>Optional registry authentication.<br />The meaning of each field is the same with the corresponding field in [`.docker/config.json`](https://docs.docker.com/engine/api/v1.41/#section/Authentication).</td>
      <td></td>
    </tr>
    <tr>
      <td>`password`</td>
      <td>string</td>
      <td>Optional registry authentication.<br />The meaning of each field is the same with the corresponding field in [`.docker/config.json`](https://docs.docker.com/engine/api/v1.41/#section/Authentication).</td>
      <td></td>
    </tr>
    <tr>
      <td>`auth`</td>
      <td>string</td>
      <td>Optional registry authentication.<br />The meaning of each field is the same with the corresponding field in [`.docker/config.json`](https://docs.docker.com/engine/api/v1.41/#section/Authentication).</td>
      <td></td>
    </tr>
    <tr>
      <td>`identityToken`</td>
      <td>string</td>
      <td>Optional registry authentication.<br />The meaning of each field is the same with the corresponding field in [`.docker/config.json`](https://docs.docker.com/engine/api/v1.41/#section/Authentication).</td>
      <td></td>
    </tr>
  </tbody>
</table>









### features

FeaturesConfig describes individual Talos features that can be switched on or off.



```yaml
machine:
    features:
        rbac: true # Enable role-based access control (RBAC).

        # # Configure Talos API access from Kubernetes pods.
        # kubernetesTalosAPIAccess:
        #     enabled: true # Enable Talos API access from Kubernetes pods.
        #     # The list of Talos API roles which can be granted for access from Kubernetes pods.
        #     allowedRoles:
        #         - os:reader
        #     # The list of Kubernetes namespaces Talos API access is available from.
        #     allowedKubernetesNamespaces:
        #         - kube-system
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`rbac`</td>
      <td>bool</td>
      <td>Enable role-based access control (RBAC).</td>
      <td></td>
    </tr>
    <tr>
      <td>`kubernetesTalosAPIAccess`</td>
      <td><a href="#kubernetesTalosAPIAccess">KubernetesTalosAPIAccessConfig</a></td>
      <td>Configure Talos API access from Kubernetes pods.<br /><br />This feature is disabled if the feature config is not specified.</td>
      <td></td>
    </tr>
    <tr>
      <td>`apidCheckExtKeyUsage`</td>
      <td>bool</td>
      <td>Enable checks for extended key usage of client certificates in apid.</td>
      <td></td>
    </tr>
    <tr>
      <td>`diskQuotaSupport`</td>
      <td>bool</td>
      <td>Enable XFS project quota support for EPHEMERAL partition and user disks.<br />Also enables kubelet tracking of ephemeral disk usage in the kubelet via quota.</td>
      <td></td>
    </tr>
    <tr>
      <td>`kubePrism`</td>
      <td><a href="#kubePrism">KubePrism</a></td>
      <td>KubePrism - local proxy/load balancer on defined port that will distribute<br />requests to all API servers in the cluster.</td>
      <td></td>
    </tr>
    <tr>
      <td>`hostDNS`</td>
      <td><a href="#hostDNS">HostDNSConfig</a></td>
      <td>Configures host DNS caching resolver.</td>
      <td></td>
    </tr>
    <tr>
      <td>`imageCache`</td>
      <td><a href="#imageCache">ImageCacheConfig</a></td>
      <td>Enable Image Cache feature.</td>
      <td></td>
    </tr>
    <tr>
      <td>`nodeAddressSortAlgorithm`</td>
      <td>string</td>
      <td>Select the node address sort algorithm.<br />The 'v1' algorithm sorts addresses by the address itself.<br />The 'v2' algorithm prefers more specific prefixes.<br />If unset, defaults to 'v1'.</td>
      <td></td>
    </tr>
  </tbody>
</table>



#### kubernetesTalosAPIAccess

KubernetesTalosAPIAccessConfig describes the configuration for the Talos API access from Kubernetes pods.



```yaml
machine:
    features:
        kubernetesTalosAPIAccess:
            enabled: true # Enable Talos API access from Kubernetes pods.
            # The list of Talos API roles which can be granted for access from Kubernetes pods.
            allowedRoles:
                - os:reader
            # The list of Kubernetes namespaces Talos API access is available from.
            allowedKubernetesNamespaces:
                - kube-system
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`enabled`</td>
      <td>bool</td>
      <td>Enable Talos API access from Kubernetes pods.</td>
      <td></td>
    </tr>
    <tr>
      <td>`allowedRoles`</td>
      <td>[]string</td>
      <td>The list of Talos API roles which can be granted for access from Kubernetes pods.<br /><br />Empty list means that no roles can be granted, so access is blocked.</td>
      <td></td>
    </tr>
    <tr>
      <td>`allowedKubernetesNamespaces`</td>
      <td>[]string</td>
      <td>The list of Kubernetes namespaces Talos API access is available from.</td>
      <td></td>
    </tr>
  </tbody>
</table>





#### kubePrism

KubePrism describes the configuration for the KubePrism load balancer.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`enabled`</td>
      <td>bool</td>
      <td>Enable KubePrism support - will start local load balancing proxy.</td>
      <td></td>
    </tr>
    <tr>
      <td>`port`</td>
      <td>int</td>
      <td>KubePrism port.</td>
      <td></td>
    </tr>
  </tbody>
</table>





#### hostDNS

HostDNSConfig describes the configuration for the host DNS resolver.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`enabled`</td>
      <td>bool</td>
      <td>Enable host DNS caching resolver.</td>
      <td></td>
    </tr>
    <tr>
      <td>`forwardKubeDNSToHost`</td>
      <td>bool</td>
      <td>Use the host DNS resolver as upstream for Kubernetes CoreDNS pods.<br /><br />When enabled, CoreDNS pods use host DNS server as the upstream DNS (instead of<br />using configured upstream DNS resolvers directly).</td>
      <td></td>
    </tr>
    <tr>
      <td>`resolveMemberNames`</td>
      <td>bool</td>
      <td>Resolve member hostnames using the host DNS resolver.<br /><br />When enabled, cluster member hostnames and node names are resolved using the host DNS resolver.<br />This requires service discovery to be enabled.</td>
      <td></td>
    </tr>
  </tbody>
</table>





#### imageCache

ImageCacheConfig describes the configuration for the Image Cache feature.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`localEnabled`</td>
      <td>bool</td>
      <td>Enable local image cache.</td>
      <td></td>
    </tr>
  </tbody>
</table>







### udev

UdevConfig describes how the udev system should be configured.



```yaml
machine:
    udev:
        # List of udev rules to apply to the udev system
        rules:
            - SUBSYSTEM=="drm", KERNEL=="renderD*", GROUP="44", MODE="0660"
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`rules`</td>
      <td>[]string</td>
      <td>List of udev rules to apply to the udev system</td>
      <td></td>
    </tr>
  </tbody>
</table>





### logging

LoggingConfig struct configures Talos logging.



```yaml
machine:
    logging:
        # Logging destination.
        destinations:
            - endpoint: tcp://1.2.3.4:12345 # Where to send logs. Supported protocols are "tcp" and "udp".
              format: json_lines # Logs format.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`destinations`</td>
      <td><a href="#destinations.">[]LoggingDestination</a></td>
      <td>Logging destination.</td>
      <td></td>
    </tr>
  </tbody>
</table>



#### destinations[]

LoggingDestination struct configures Talos logging destination.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`endpoint`</td>
      <td><a href="#endpoint">Endpoint</a></td>
      <td>Where to send logs. Supported protocols are "tcp" and "udp".</td>
      <td></td>
    </tr>
    <tr>
      <td>`format`</td>
      <td>string</td>
      <td>Logs format.</td>
      <td>`json_lines`<br /></td>
    </tr>
    <tr>
      <td>`extraTags`</td>
      <td>map[string]string</td>
      <td>Extra tags (key-value) pairs to attach to every log message sent.</td>
      <td></td>
    </tr>
  </tbody>
</table>



##### endpoint

Endpoint represents the endpoint URL parsed out of the machine config.



```yaml
machine:
    logging:
        destinations:
            - endpoint: https://1.2.3.4:6443
```

```yaml
machine:
    logging:
        destinations:
            - endpoint: https://cluster1.internal:6443
```

```yaml
machine:
    logging:
        destinations:
            - endpoint: udp://127.0.0.1:12345
```

```yaml
machine:
    logging:
        destinations:
            - endpoint: tcp://1.2.3.4:12345
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>










### kernel

KernelConfig struct configures Talos Linux kernel.



```yaml
machine:
    kernel:
        # Kernel modules to load.
        modules:
            - name: btrfs # Module name.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`modules`</td>
      <td><a href="#modules.">[]KernelModuleConfig</a></td>
      <td>Kernel modules to load.</td>
      <td></td>
    </tr>
  </tbody>
</table>



#### modules[]

KernelModuleConfig struct configures Linux kernel modules to load.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`name`</td>
      <td>string</td>
      <td>Module name.</td>
      <td></td>
    </tr>
    <tr>
      <td>`parameters`</td>
      <td>[]string</td>
      <td>Module parameters, changes applied after reboot.</td>
      <td></td>
    </tr>
  </tbody>
</table>







### seccompProfiles[]

MachineSeccompProfile defines seccomp profiles for the machine.



```yaml
machine:
    seccompProfiles:
        - name: audit.json # The `name` field is used to provide the file name of the seccomp profile.
          # The `value` field is used to provide the seccomp profile.
          value:
            defaultAction: SCMP_ACT_LOG
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`name`</td>
      <td>string</td>
      <td>The `name` field is used to provide the file name of the seccomp profile.</td>
      <td></td>
    </tr>
    <tr>
      <td>`value`</td>
      <td>Unstructured</td>
      <td>The `value` field is used to provide the seccomp profile.</td>
      <td></td>
    </tr>
  </tbody>
</table>







## cluster

ClusterConfig represents the cluster-wide config values.



```yaml
cluster:
    # ControlPlaneConfig represents the control plane configuration options.
    controlPlane:
        endpoint: https://1.2.3.4 # Endpoint is the canonical controlplane endpoint, which can be an IP address or a DNS hostname.
        localAPIServerPort: 443 # The port that the API server listens on internally.
    clusterName: talos.local
    # ClusterNetworkConfig represents kube networking configuration options.
    network:
        # The CNI used.
        cni:
            name: flannel # Name of CNI to use.
        dnsDomain: cluster.local # The domain used by Kubernetes DNS.
        # The pod subnet CIDR.
        podSubnets:
            - 10.244.0.0/16
        # The service subnet CIDR.
        serviceSubnets:
            - 10.96.0.0/12
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`id`</td>
      <td>string</td>
      <td>Globally unique identifier for this cluster (base64 encoded random 32 bytes).</td>
      <td></td>
    </tr>
    <tr>
      <td>`secret`</td>
      <td>string</td>
      <td>Shared secret of cluster (base64 encoded random 32 bytes).<br />This secret is shared among cluster members but should never be sent over the network.</td>
      <td></td>
    </tr>
    <tr>
      <td>`controlPlane`</td>
      <td><a href="#controlPlane">ControlPlaneConfig</a></td>
      <td>Provides control plane specific configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`clusterName`</td>
      <td>string</td>
      <td>Configures the cluster's name.</td>
      <td></td>
    </tr>
    <tr>
      <td>`network`</td>
      <td><a href="#network">ClusterNetworkConfig</a></td>
      <td>Provides cluster specific network configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`token`</td>
      <td>string</td>
      <td>The [bootstrap token](https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens/) used to join the cluster.</td>
      <td></td>
    </tr>
    <tr>
      <td>`aescbcEncryptionSecret`</td>
      <td>string</td>
      <td>A key used for the [encryption of secret data at rest](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/).<br />Enables encryption with AESCBC.</td>
      <td></td>
    </tr>
    <tr>
      <td>`secretboxEncryptionSecret`</td>
      <td>string</td>
      <td>A key used for the [encryption of secret data at rest](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/).<br />Enables encryption with secretbox.<br />Secretbox has precedence over AESCBC.</td>
      <td></td>
    </tr>
    <tr>
      <td>`ca`</td>
      <td>PEMEncodedCertificateAndKey</td>
      <td>The base64 encoded root certificate authority used by Kubernetes.</td>
      <td></td>
    </tr>
    <tr>
      <td>`acceptedCAs`</td>
      <td>[]PEMEncodedCertificate</td>
      <td>The list of base64 encoded accepted certificate authorities used by Kubernetes.</td>
      <td></td>
    </tr>
    <tr>
      <td>`aggregatorCA`</td>
      <td>PEMEncodedCertificateAndKey</td>
      <td>The base64 encoded aggregator certificate authority used by Kubernetes for front-proxy certificate generation.<br /><br />This CA can be self-signed.</td>
      <td></td>
    </tr>
    <tr>
      <td>`serviceAccount`</td>
      <td>PEMEncodedKey</td>
      <td>The base64 encoded private key for service account token generation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`apiServer`</td>
      <td><a href="#apiServer">APIServerConfig</a></td>
      <td>API server specific configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`controllerManager`</td>
      <td><a href="#controllerManager">ControllerManagerConfig</a></td>
      <td>Controller manager server specific configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`proxy`</td>
      <td><a href="#proxy">ProxyConfig</a></td>
      <td>Kube-proxy server-specific configuration options</td>
      <td></td>
    </tr>
    <tr>
      <td>`scheduler`</td>
      <td><a href="#scheduler">SchedulerConfig</a></td>
      <td>Scheduler server specific configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`discovery`</td>
      <td><a href="#discovery">ClusterDiscoveryConfig</a></td>
      <td>Configures cluster member discovery.</td>
      <td></td>
    </tr>
    <tr>
      <td>`etcd`</td>
      <td><a href="#etcd">EtcdConfig</a></td>
      <td>Etcd specific configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`coreDNS`</td>
      <td><a href="#coreDNS">CoreDNS</a></td>
      <td>Core DNS specific configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`externalCloudProvider`</td>
      <td><a href="#externalCloudProvider">ExternalCloudProviderConfig</a></td>
      <td>External cloud provider configuration.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraManifests`</td>
      <td>[]string</td>
      <td>A list of urls that point to additional manifests.<br />These will get automatically deployed as part of the bootstrap.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraManifestHeaders`</td>
      <td>map[string]string</td>
      <td>A map of key value pairs that will be added while fetching the extraManifests.</td>
      <td></td>
    </tr>
    <tr>
      <td>`inlineManifests`</td>
      <td><a href="#inlineManifests.">[]ClusterInlineManifest</a></td>
      <td>A list of inline Kubernetes manifests.<br />These will get automatically deployed as part of the bootstrap.</td>
      <td></td>
    </tr>
    <tr>
      <td>`adminKubeconfig`</td>
      <td><a href="#adminKubeconfig">AdminKubeconfigConfig</a></td>
      <td>Settings for admin kubeconfig generation.<br />Certificate lifetime can be configured.</td>
      <td></td>
    </tr>
    <tr>
      <td>`allowSchedulingOnControlPlanes`</td>
      <td>bool</td>
      <td>Allows running workload on control-plane nodes.</td>
      <td>`true`<br />`yes`<br />`false`<br />`no`<br /></td>
    </tr>
  </tbody>
</table>



### controlPlane

ControlPlaneConfig represents the control plane configuration options.



```yaml
cluster:
    controlPlane:
        endpoint: https://1.2.3.4 # Endpoint is the canonical controlplane endpoint, which can be an IP address or a DNS hostname.
        localAPIServerPort: 443 # The port that the API server listens on internally.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`endpoint`</td>
      <td><a href="#endpoint">Endpoint</a></td>
      <td>Endpoint is the canonical controlplane endpoint, which can be an IP address or a DNS hostname.<br />It is single-valued, and may optionally include a port number.</td>
      <td></td>
    </tr>
    <tr>
      <td>`localAPIServerPort`</td>
      <td>int</td>
      <td>The port that the API server listens on internally.<br />This may be different than the port portion listed in the endpoint field above.<br />The default is `6443`.</td>
      <td></td>
    </tr>
  </tbody>
</table>



#### endpoint

Endpoint represents the endpoint URL parsed out of the machine config.



```yaml
cluster:
    controlPlane:
        endpoint: https://1.2.3.4:6443
```

```yaml
cluster:
    controlPlane:
        endpoint: https://cluster1.internal:6443
```

```yaml
cluster:
    controlPlane:
        endpoint: udp://127.0.0.1:12345
```

```yaml
cluster:
    controlPlane:
        endpoint: tcp://1.2.3.4:12345
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>








### network

ClusterNetworkConfig represents kube networking configuration options.



```yaml
cluster:
    network:
        # The CNI used.
        cni:
            name: flannel # Name of CNI to use.
        dnsDomain: cluster.local # The domain used by Kubernetes DNS.
        # The pod subnet CIDR.
        podSubnets:
            - 10.244.0.0/16
        # The service subnet CIDR.
        serviceSubnets:
            - 10.96.0.0/12
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`cni`</td>
      <td><a href="#cni">CNIConfig</a></td>
      <td>The CNI used.<br />Composed of "name" and "urls".<br />The "name" key supports the following options: "flannel", "custom", and "none".<br />"flannel" uses Talos-managed Flannel CNI, and that's the default option.<br />"custom" uses custom manifests that should be provided in "urls".<br />"none" indicates that Talos will not manage any CNI installation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`dnsDomain`</td>
      <td>string</td>
      <td>The domain used by Kubernetes DNS.<br />The default is `cluster.local`</td>
      <td></td>
    </tr>
    <tr>
      <td>`podSubnets`</td>
      <td>[]string</td>
      <td>The pod subnet CIDR.</td>
      <td></td>
    </tr>
    <tr>
      <td>`serviceSubnets`</td>
      <td>[]string</td>
      <td>The service subnet CIDR.</td>
      <td></td>
    </tr>
  </tbody>
</table>



#### cni

CNIConfig represents the CNI configuration options.



```yaml
cluster:
    network:
        cni:
            name: custom # Name of CNI to use.
            # URLs containing manifests to apply for the CNI.
            urls:
                - https://docs.projectcalico.org/archive/v3.20/manifests/canal.yaml
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`name`</td>
      <td>string</td>
      <td>Name of CNI to use.</td>
      <td>`flannel`<br />`custom`<br />`none`<br /></td>
    </tr>
    <tr>
      <td>`urls`</td>
      <td>[]string</td>
      <td>URLs containing manifests to apply for the CNI.<br />Should be present for "custom", must be empty for "flannel" and "none".</td>
      <td></td>
    </tr>
    <tr>
      <td>`flannel`</td>
      <td><a href="#flannel">FlannelCNIConfig</a></td>
      <td>description:</td>
      <td><br />Flannel configuration options.<br /></td>
      <td></td>
    </tr>
  </tbody>
</table>



##### flannel

FlannelCNIConfig represents the Flannel CNI configuration options.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`extraArgs`</td>
      <td>[]string</td>
      <td>Extra arguments for 'flanneld'.</td>
      <td></td>
    </tr>
  </tbody>
</table>









### apiServer

APIServerConfig represents the kube apiserver configuration options.



```yaml
cluster:
    apiServer:
        image: registry.k8s.io/kube-apiserver:v1.34.1 # The container image used in the API server manifest.
        # Extra arguments to supply to the API server.
        extraArgs:
            feature-gates: ServerSideApply=true
            http2-max-streams-per-connection: "32"
        # Extra certificate subject alternative names for the API server's certificate.
        certSANs:
            - 1.2.3.4
            - 4.5.6.7

        # # Configure the API server admission plugins.
        # admissionControl:
        #     - name: PodSecurity # Name is the name of the admission controller.
        #       # Configuration is an embedded configuration object to be used as the plugin's
        #       configuration:
        #         apiVersion: pod-security.admission.config.k8s.io/v1alpha1
        #         defaults:
        #             audit: restricted
        #             audit-version: latest
        #             enforce: baseline
        #             enforce-version: latest
        #             warn: restricted
        #             warn-version: latest
        #         exemptions:
        #             namespaces:
        #                 - kube-system
        #             runtimeClasses: []
        #             usernames: []
        #         kind: PodSecurityConfiguration

        # # Configure the API server audit policy.
        # auditPolicy:
        #     apiVersion: audit.k8s.io/v1
        #     kind: Policy
        #     rules:
        #         - level: Metadata

        # # Configure the API server authorization config. Node and RBAC authorizers are always added irrespective of the configuration.
        # authorizationConfig:
        #     - type: Webhook # Type is the name of the authorizer. Allowed values are `Node`, `RBAC`, and `Webhook`.
        #       name: webhook # Name is used to describe the authorizer.
        #       # webhook is the configuration for the webhook authorizer.
        #       webhook:
        #         connectionInfo:
        #             type: InClusterConfig
        #         failurePolicy: Deny
        #         matchConditionSubjectAccessReviewVersion: v1
        #         matchConditions:
        #             - expression: has(request.resourceAttributes)
        #             - expression: '!(\''system:serviceaccounts:kube-system\'' in request.groups)'
        #         subjectAccessReviewVersion: v1
        #         timeout: 3s
        #     - type: Webhook # Type is the name of the authorizer. Allowed values are `Node`, `RBAC`, and `Webhook`.
        #       name: in-cluster-authorizer # Name is used to describe the authorizer.
        #       # webhook is the configuration for the webhook authorizer.
        #       webhook:
        #         connectionInfo:
        #             type: InClusterConfig
        #         failurePolicy: NoOpinion
        #         matchConditionSubjectAccessReviewVersion: v1
        #         subjectAccessReviewVersion: v1
        #         timeout: 3s
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`image`</td>
      <td>string</td>
      <td>The container image used in the API server manifest.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraArgs`</td>
      <td>map[string]string</td>
      <td>Extra arguments to supply to the API server.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraVolumes`</td>
      <td><a href="#extraVolumes.">[]VolumeMountConfig</a></td>
      <td>Extra volumes to mount to the API server static pod.</td>
      <td></td>
    </tr>
    <tr>
      <td>`env`</td>
      <td>Env</td>
      <td>The `env` field allows for the addition of environment variables for the control plane component.</td>
      <td></td>
    </tr>
    <tr>
      <td>`certSANs`</td>
      <td>[]string</td>
      <td>Extra certificate subject alternative names for the API server's certificate.</td>
      <td></td>
    </tr>
    <tr>
      <td>`disablePodSecurityPolicy`</td>
      <td>bool</td>
      <td>Disable PodSecurityPolicy in the API server and default manifests.</td>
      <td></td>
    </tr>
    <tr>
      <td>`admissionControl`</td>
      <td><a href="#admissionControl.">[]AdmissionPluginConfig</a></td>
      <td>Configure the API server admission plugins.</td>
      <td></td>
    </tr>
    <tr>
      <td>`auditPolicy`</td>
      <td>Unstructured</td>
      <td>Configure the API server audit policy.</td>
      <td></td>
    </tr>
    <tr>
      <td>`resources`</td>
      <td><a href="#resources">ResourcesConfig</a></td>
      <td>Configure the API server resources.</td>
      <td></td>
    </tr>
    <tr>
      <td>`authorizationConfig`</td>
      <td><a href="#authorizationConfig.">[]AuthorizationConfigAuthorizerConfig</a></td>
      <td>Configure the API server authorization config. Node and RBAC authorizers are always added irrespective of the configuration.</td>
      <td></td>
    </tr>
  </tbody>
</table>



#### extraVolumes[]

VolumeMountConfig struct describes extra volume mount for the static pods.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`hostPath`</td>
      <td>string</td>
      <td>Path on the host.</td>
      <td></td>
    </tr>
    <tr>
      <td>`mountPath`</td>
      <td>string</td>
      <td>Path in the container.</td>
      <td></td>
    </tr>
    <tr>
      <td>`readonly`</td>
      <td>bool</td>
      <td>Mount the volume read only.</td>
      <td></td>
    </tr>
  </tbody>
</table>





#### admissionControl[]

AdmissionPluginConfig represents the API server admission plugin configuration.



```yaml
cluster:
    apiServer:
        admissionControl:
            - name: PodSecurity # Name is the name of the admission controller.
              # Configuration is an embedded configuration object to be used as the plugin's
              configuration:
                apiVersion: pod-security.admission.config.k8s.io/v1alpha1
                defaults:
                    audit: restricted
                    audit-version: latest
                    enforce: baseline
                    enforce-version: latest
                    warn: restricted
                    warn-version: latest
                exemptions:
                    namespaces:
                        - kube-system
                    runtimeClasses: []
                    usernames: []
                kind: PodSecurityConfiguration
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`name`</td>
      <td>string</td>
      <td>Name is the name of the admission controller.<br />It must match the registered admission plugin name.</td>
      <td></td>
    </tr>
    <tr>
      <td>`configuration`</td>
      <td>Unstructured</td>
      <td>Configuration is an embedded configuration object to be used as the plugin's<br />configuration.</td>
      <td></td>
    </tr>
  </tbody>
</table>





#### resources

ResourcesConfig represents the pod resources.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`requests`</td>
      <td>Unstructured</td>
      <td>Requests configures the reserved cpu/memory resources.</td>
      <td></td>
    </tr>
    <tr>
      <td>`limits`</td>
      <td>Unstructured</td>
      <td>Limits configures the maximum cpu/memory resources a container can use.</td>
      <td></td>
    </tr>
  </tbody>
</table>





#### authorizationConfig[]

AuthorizationConfigAuthorizerConfig represents the API server authorization config authorizer configuration.



```yaml
cluster:
    apiServer:
        authorizationConfig:
            - type: Webhook # Type is the name of the authorizer. Allowed values are `Node`, `RBAC`, and `Webhook`.
              name: webhook # Name is used to describe the authorizer.
              # webhook is the configuration for the webhook authorizer.
              webhook:
                connectionInfo:
                    type: InClusterConfig
                failurePolicy: Deny
                matchConditionSubjectAccessReviewVersion: v1
                matchConditions:
                    - expression: has(request.resourceAttributes)
                    - expression: '!(\''system:serviceaccounts:kube-system\'' in request.groups)'
                subjectAccessReviewVersion: v1
                timeout: 3s
            - type: Webhook # Type is the name of the authorizer. Allowed values are `Node`, `RBAC`, and `Webhook`.
              name: in-cluster-authorizer # Name is used to describe the authorizer.
              # webhook is the configuration for the webhook authorizer.
              webhook:
                connectionInfo:
                    type: InClusterConfig
                failurePolicy: NoOpinion
                matchConditionSubjectAccessReviewVersion: v1
                subjectAccessReviewVersion: v1
                timeout: 3s
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`type`</td>
      <td>string</td>
      <td>Type is the name of the authorizer. Allowed values are `Node`, `RBAC`, and `Webhook`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`name`</td>
      <td>string</td>
      <td>Name is used to describe the authorizer.</td>
      <td></td>
    </tr>
    <tr>
      <td>`webhook`</td>
      <td>Unstructured</td>
      <td>webhook is the configuration for the webhook authorizer.</td>
      <td></td>
    </tr>
  </tbody>
</table>







### controllerManager

ControllerManagerConfig represents the kube controller manager configuration options.



```yaml
cluster:
    controllerManager:
        image: registry.k8s.io/kube-controller-manager:v1.34.1 # The container image used in the controller manager manifest.
        # Extra arguments to supply to the controller manager.
        extraArgs:
            feature-gates: ServerSideApply=true
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`image`</td>
      <td>string</td>
      <td>The container image used in the controller manager manifest.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraArgs`</td>
      <td>map[string]string</td>
      <td>Extra arguments to supply to the controller manager.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraVolumes`</td>
      <td><a href="#extraVolumes.">[]VolumeMountConfig</a></td>
      <td>Extra volumes to mount to the controller manager static pod.</td>
      <td></td>
    </tr>
    <tr>
      <td>`env`</td>
      <td>Env</td>
      <td>The `env` field allows for the addition of environment variables for the control plane component.</td>
      <td></td>
    </tr>
    <tr>
      <td>`resources`</td>
      <td><a href="#resources">ResourcesConfig</a></td>
      <td>Configure the controller manager resources.</td>
      <td></td>
    </tr>
  </tbody>
</table>



#### extraVolumes[]

VolumeMountConfig struct describes extra volume mount for the static pods.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`hostPath`</td>
      <td>string</td>
      <td>Path on the host.</td>
      <td></td>
    </tr>
    <tr>
      <td>`mountPath`</td>
      <td>string</td>
      <td>Path in the container.</td>
      <td></td>
    </tr>
    <tr>
      <td>`readonly`</td>
      <td>bool</td>
      <td>Mount the volume read only.</td>
      <td></td>
    </tr>
  </tbody>
</table>





#### resources

ResourcesConfig represents the pod resources.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`requests`</td>
      <td>Unstructured</td>
      <td>Requests configures the reserved cpu/memory resources.</td>
      <td></td>
    </tr>
    <tr>
      <td>`limits`</td>
      <td>Unstructured</td>
      <td>Limits configures the maximum cpu/memory resources a container can use.</td>
      <td></td>
    </tr>
  </tbody>
</table>







### proxy

ProxyConfig represents the kube proxy configuration options.



```yaml
cluster:
    proxy:
        image: registry.k8s.io/kube-proxy:v1.34.1 # The container image used in the kube-proxy manifest.
        mode: ipvs # proxy mode of kube-proxy.
        # Extra arguments to supply to kube-proxy.
        extraArgs:
            proxy-mode: iptables

        # # Disable kube-proxy deployment on cluster bootstrap.
        # disabled: false
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`disabled`</td>
      <td>bool</td>
      <td>Disable kube-proxy deployment on cluster bootstrap.</td>
      <td></td>
    </tr>
    <tr>
      <td>`image`</td>
      <td>string</td>
      <td>The container image used in the kube-proxy manifest.</td>
      <td></td>
    </tr>
    <tr>
      <td>`mode`</td>
      <td>string</td>
      <td>proxy mode of kube-proxy.<br />The default is 'iptables'.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraArgs`</td>
      <td>map[string]string</td>
      <td>Extra arguments to supply to kube-proxy.</td>
      <td></td>
    </tr>
  </tbody>
</table>





### scheduler

SchedulerConfig represents the kube scheduler configuration options.



```yaml
cluster:
    scheduler:
        image: registry.k8s.io/kube-scheduler:v1.34.1 # The container image used in the scheduler manifest.
        # Extra arguments to supply to the scheduler.
        extraArgs:
            feature-gates: AllBeta=true
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`image`</td>
      <td>string</td>
      <td>The container image used in the scheduler manifest.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraArgs`</td>
      <td>map[string]string</td>
      <td>Extra arguments to supply to the scheduler.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraVolumes`</td>
      <td><a href="#extraVolumes.">[]VolumeMountConfig</a></td>
      <td>Extra volumes to mount to the scheduler static pod.</td>
      <td></td>
    </tr>
    <tr>
      <td>`env`</td>
      <td>Env</td>
      <td>The `env` field allows for the addition of environment variables for the control plane component.</td>
      <td></td>
    </tr>
    <tr>
      <td>`resources`</td>
      <td><a href="#resources">ResourcesConfig</a></td>
      <td>Configure the scheduler resources.</td>
      <td></td>
    </tr>
    <tr>
      <td>`config`</td>
      <td>Unstructured</td>
      <td>Specify custom kube-scheduler configuration.</td>
      <td></td>
    </tr>
  </tbody>
</table>



#### extraVolumes[]

VolumeMountConfig struct describes extra volume mount for the static pods.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`hostPath`</td>
      <td>string</td>
      <td>Path on the host.</td>
      <td></td>
    </tr>
    <tr>
      <td>`mountPath`</td>
      <td>string</td>
      <td>Path in the container.</td>
      <td></td>
    </tr>
    <tr>
      <td>`readonly`</td>
      <td>bool</td>
      <td>Mount the volume read only.</td>
      <td></td>
    </tr>
  </tbody>
</table>





#### resources

ResourcesConfig represents the pod resources.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`requests`</td>
      <td>Unstructured</td>
      <td>Requests configures the reserved cpu/memory resources.</td>
      <td></td>
    </tr>
    <tr>
      <td>`limits`</td>
      <td>Unstructured</td>
      <td>Limits configures the maximum cpu/memory resources a container can use.</td>
      <td></td>
    </tr>
  </tbody>
</table>







### discovery

ClusterDiscoveryConfig struct configures cluster membership discovery.



```yaml
cluster:
    discovery:
        enabled: true # Enable the cluster membership discovery feature.
        # Configure registries used for cluster member discovery.
        registries:
            # Kubernetes registry uses Kubernetes API server to discover cluster members and stores additional information
            kubernetes: {}
            # Service registry is using an external service to push and pull information about cluster members.
            service:
                endpoint: https://discovery.talos.dev/ # External service endpoint.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`enabled`</td>
      <td>bool</td>
      <td>Enable the cluster membership discovery feature.<br />Cluster discovery is based on individual registries which are configured under the registries field.</td>
      <td></td>
    </tr>
    <tr>
      <td>`registries`</td>
      <td><a href="#registries">DiscoveryRegistriesConfig</a></td>
      <td>Configure registries used for cluster member discovery.</td>
      <td></td>
    </tr>
  </tbody>
</table>



#### registries

DiscoveryRegistriesConfig struct configures cluster membership discovery.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`kubernetes`</td>
      <td><a href="#kubernetes">RegistryKubernetesConfig</a></td>
      <td>Kubernetes registry uses Kubernetes API server to discover cluster members and stores additional information<br />as annotations on the Node resources.<br /><br />This feature is deprecated as it is not compatible with Kubernetes 1.32+.<br />See https://github.com/siderolabs/talos/issues/9980 for more information.</td>
      <td></td>
    </tr>
    <tr>
      <td>`service`</td>
      <td><a href="#service">RegistryServiceConfig</a></td>
      <td>Service registry is using an external service to push and pull information about cluster members.</td>
      <td></td>
    </tr>
  </tbody>
</table>



##### kubernetes

RegistryKubernetesConfig struct configures Kubernetes discovery registry.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`disabled`</td>
      <td>bool</td>
      <td>Disable Kubernetes discovery registry.</td>
      <td></td>
    </tr>
  </tbody>
</table>





##### service

RegistryServiceConfig struct configures Kubernetes discovery registry.




<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`disabled`</td>
      <td>bool</td>
      <td>Disable external service discovery registry.</td>
      <td></td>
    </tr>
    <tr>
      <td>`endpoint`</td>
      <td>string</td>
      <td>External service endpoint.</td>
      <td></td>
    </tr>
  </tbody>
</table>









### etcd

EtcdConfig represents the etcd configuration options.



```yaml
cluster:
    etcd:
        image: gcr.io/etcd-development/etcd:v3.6.5 # The container image used to create the etcd service.
        # The `ca` is the root certificate authority of the PKI.
        ca:
            crt: LS0tIEVYQU1QTEUgQ0VSVElGSUNBVEUgLS0t
            key: LS0tIEVYQU1QTEUgS0VZIC0tLQ==
        # Extra arguments to supply to etcd.
        extraArgs:
            election-timeout: "5000"

        # # The `advertisedSubnets` field configures the networks to pick etcd advertised IP from.
        # advertisedSubnets:
        #     - 10.0.0.0/8
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`image`</td>
      <td>string</td>
      <td>The container image used to create the etcd service.</td>
      <td></td>
    </tr>
    <tr>
      <td>`ca`</td>
      <td>PEMEncodedCertificateAndKey</td>
      <td>The `ca` is the root certificate authority of the PKI.<br />It is composed of a base64 encoded `crt` and `key`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraArgs`</td>
      <td>map[string]string</td>
      <td>Extra arguments to supply to etcd.<br />Note that the following args are not allowed:<br /><br />- `name`<br />- `data-dir`<br />- `initial-cluster-state`<br />- `listen-peer-urls`<br />- `listen-client-urls`<br />- `cert-file`<br />- `key-file`<br />- `trusted-ca-file`<br />- `peer-client-cert-auth`<br />- `peer-cert-file`<br />- `peer-trusted-ca-file`<br />- `peer-key-file`</td>
      <td></td>
    </tr>
    <tr>
      <td>`advertisedSubnets`</td>
      <td>[]string</td>
      <td>The `advertisedSubnets` field configures the networks to pick etcd advertised IP from.<br /><br />IPs can be excluded from the list by using negative match with `!`, e.g `!10.0.0.0/8`.<br />Negative subnet matches should be specified last to filter out IPs picked by positive matches.<br />If not specified, advertised IP is selected as the first routable address of the node.</td>
      <td></td>
    </tr>
    <tr>
      <td>`listenSubnets`</td>
      <td>[]string</td>
      <td>The `listenSubnets` field configures the networks for the etcd to listen for peer and client connections.<br /><br />If `listenSubnets` is not set, but `advertisedSubnets` is set, `listenSubnets` defaults to<br />`advertisedSubnets`.<br /><br />If neither `advertisedSubnets` nor `listenSubnets` is set, `listenSubnets` defaults to listen on all addresses.<br /><br />IPs can be excluded from the list by using negative match with `!`, e.g `!10.0.0.0/8`.<br />Negative subnet matches should be specified last to filter out IPs picked by positive matches.<br />If not specified, advertised IP is selected as the first routable address of the node.</td>
      <td></td>
    </tr>
  </tbody>
</table>





### coreDNS

CoreDNS represents the CoreDNS config values.



```yaml
cluster:
    coreDNS:
        image: registry.k8s.io/coredns/coredns:v1.12.4 # The `image` field is an override to the default coredns image.
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`disabled`</td>
      <td>bool</td>
      <td>Disable coredns deployment on cluster bootstrap.</td>
      <td></td>
    </tr>
    <tr>
      <td>`image`</td>
      <td>string</td>
      <td>The `image` field is an override to the default coredns image.</td>
      <td></td>
    </tr>
  </tbody>
</table>





### externalCloudProvider

ExternalCloudProviderConfig contains external cloud provider configuration.



```yaml
cluster:
    externalCloudProvider:
        enabled: true # Enable external cloud provider.
        # A list of urls that point to additional manifests for an external cloud provider.
        manifests:
            - https://raw.githubusercontent.com/kubernetes/cloud-provider-aws/v1.20.0-alpha.0/manifests/rbac.yaml
            - https://raw.githubusercontent.com/kubernetes/cloud-provider-aws/v1.20.0-alpha.0/manifests/aws-cloud-controller-manager-daemonset.yaml
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`enabled`</td>
      <td>bool</td>
      <td>Enable external cloud provider.</td>
      <td>`true`<br />`yes`<br />`false`<br />`no`<br /></td>
    </tr>
    <tr>
      <td>`manifests`</td>
      <td>[]string</td>
      <td>A list of urls that point to additional manifests for an external cloud provider.<br />These will get automatically deployed as part of the bootstrap.</td>
      <td></td>
    </tr>
  </tbody>
</table>





### inlineManifests[]

ClusterInlineManifest struct describes inline bootstrap manifests for the user.



```yaml
cluster:
    inlineManifests:
        - name: namespace-ci # Name of the manifest.
          contents: |- # Manifest contents as a string.
            apiVersion: v1
            kind: Namespace
            metadata:
            	name: ci
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`name`</td>
      <td>string</td>
      <td>Name of the manifest.<br />Name should be unique.</td>
      <td></td>
    </tr>
    <tr>
      <td>`contents`</td>
      <td>string</td>
      <td>Manifest contents as a string.</td>
      <td></td>
    </tr>
  </tbody>
</table>





### adminKubeconfig

AdminKubeconfigConfig contains admin kubeconfig settings.



```yaml
cluster:
    adminKubeconfig:
        certLifetime: 1h0m0s # Admin kubeconfig certificate lifetime (default is 1 year).
```


<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`certLifetime`</td>
      <td>Duration</td>
      <td>Admin kubeconfig certificate lifetime (default is 1 year).<br />Field format accepts any Go time.Duration format ('1h' for one hour, '10m' for ten minutes).</td>
      <td></td>
    </tr>
  </tbody>
</table>









