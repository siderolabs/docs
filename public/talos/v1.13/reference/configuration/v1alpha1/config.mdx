---
description: Config defines the v1alpha1.Config Talos machine configuration document.
title: MachineConfig
---

import { VersionWarningBanner } from "/snippets/version-warning-banner.jsx"

<VersionWarningBanner />

{/*
This file is automatically generated from source documentation.
Do not edit manually. For more information, see https://github.com/siderolabs/docs
*/}

```yaml
version: v1alpha1
machine: # ...
cluster: # ...
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`version`</td>
      <td>string</td>
      <td>Indicates the schema used to decode the contents.</td>
      <td>`v1alpha1`<br /></td>
    </tr>
    <tr>
      <td>`debug`</td>
      <td>bool</td>
      <td>Enable verbose logging to the console.<br />All system containers logs will flow into serial console.<br /><br />**Note:** To avoid breaking Talos bootstrap flow enable this option only if serial console can handle high message throughput.</td>
      <td>`true`<br />`yes`<br />`false`<br />`no`<br /></td>
    </tr>
    <tr>
      <td>`machine`</td>
      <td><a href="#machine">MachineConfig</a></td>
      <td>Provides machine specific configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`cluster`</td>
      <td><a href="#cluster">ClusterConfig</a></td>
      <td>Provides cluster specific configuration options.</td>
      <td></td>
    </tr>
  </tbody>
</table>

## machine

MachineConfig represents the machine-specific config values.

```yaml
machine:
    type: controlplane
    # InstallConfig represents the installation options for preparing a node.
    install:
        disk: /dev/sda # The disk used for installations.
        image: ghcr.io/siderolabs/installer:latest # Allows for supplying the image used to perform the installation.
        wipe: false # Indicates if the installation disk should be wiped at installation time.
        grubUseUKICmdline: true # Indicates if legacy GRUB bootloader should use kernel cmdline from the UKI instead of building it on the host.

        # # Look up disk using disk attributes like model, size, serial and others.
        # diskSelector:
        #     size: 4GB # Disk size.
        #     model: WDC* # Disk model `/sys/block/<dev>/device/model`.
        #     busPath: /pci0000:00/0000:00:17.0/ata1/host0/target0:0:0/0:0:0:0 # Disk bus path.
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`type`</td>
      <td>string</td>
      <td>Defines the role of the machine within the cluster.<br /><br />**Control Plane**<br /><br />Control Plane node type designates the node as a control plane member.<br />This means it will host etcd along with the Kubernetes controlplane components such as API Server, Controller Manager, Scheduler.<br /><br />**Worker**<br /><br />Worker node type designates the node as a worker node.<br />This means it will be an available compute node for scheduling workloads.<br /><br />This node type was previously known as "join"; that value is still supported but deprecated.</td>
      <td>`controlplane`<br />`worker`<br /></td>
    </tr>
    <tr>
      <td>`token`</td>
      <td>string</td>
      <td>The `token` is used by a machine to join the PKI of the cluster.<br />Using this token, a machine will create a certificate signing request (CSR), and request a certificate that will be used as its' identity.</td>
      <td></td>
    </tr>
    <tr>
      <td>`ca`</td>
      <td>PEMEncodedCertificateAndKey</td>
      <td>The root certificate authority of the PKI.<br />It is composed of a base64 encoded `crt` and `key`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`acceptedCAs`</td>
      <td>[]PEMEncodedCertificate</td>
      <td>The certificates issued by certificate authorities are accepted in addition to issuing 'ca'.<br />It is composed of a base64 encoded `crt``.</td>
      <td></td>
    </tr>
    <tr>
      <td>`certSANs`</td>
      <td>[]string</td>
      <td>Extra certificate subject alternative names for the machine's certificate.<br />By default, all non-loopback interface IPs are automatically added to the certificate's SANs.</td>
      <td></td>
    </tr>
    <tr>
      <td>`controlPlane`</td>
      <td><a href="#controlplane">MachineControlPlaneConfig</a></td>
      <td>Provides machine specific control plane configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`kubelet`</td>
      <td><a href="#kubelet">KubeletConfig</a></td>
      <td>Used to provide additional options to the kubelet.</td>
      <td></td>
    </tr>
    <tr>
      <td>`pods`</td>
      <td>[]Unstructured</td>
      <td>Used to provide static pod definitions to be run by the kubelet directly bypassing the kube-apiserver.<br /><br />Static pods can be used to run components which should be started before the Kubernetes control plane is up.<br />Talos doesn't validate the pod definition.<br />Updates to this field can be applied without a reboot.<br /><br />See https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/.</td>
      <td></td>
    </tr>
    <tr>
      <td>`network`</td>
      <td><a href="#network">NetworkConfig</a></td>
      <td>Provides machine specific network configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`install`</td>
      <td><a href="#install">InstallConfig</a></td>
      <td>Used to provide instructions for installations.<br /><br />Note that this configuration section gets silently ignored by Talos images that are considered pre-installed.<br />To make sure Talos installs according to the provided configuration, Talos should be booted with ISO or PXE-booted.</td>
      <td></td>
    </tr>
    <tr>
      <td>`files`</td>
      <td><a href="#files%5B%5D">MachineFile</a></td>
      <td>Allows the addition of user specified files.<br />The value of `op` can be `create`, `overwrite`, or `append`.<br />In the case of `create`, `path` must not exist.<br />In the case of `overwrite`, and `append`, `path` must be a valid file.<br />If an `op` value of `append` is used, the existing file will be appended.<br />Note that the file contents are not required to be base64 encoded.</td>
      <td></td>
    </tr>
    <tr>
      <td>`env`</td>
      <td>Env</td>
      <td>The `env` field allows for the addition of environment variables.<br />All environment variables are set on PID 1 in addition to every service.</td>
      <td>``GRPC_GO_LOG_VERBOSITY_LEVEL``<br />``GRPC_GO_LOG_SEVERITY_LEVEL``<br />``http_proxy``<br />``https_proxy``<br />``no_proxy``<br /></td>
    </tr>
    <tr>
      <td>`sysctls`</td>
      <td>map[string]string</td>
      <td>Used to configure the machine's sysctls.</td>
      <td></td>
    </tr>
    <tr>
      <td>`sysfs`</td>
      <td>map[string]string</td>
      <td>Used to configure the machine's sysfs.</td>
      <td></td>
    </tr>
    <tr>
      <td>`features`</td>
      <td><a href="#features">FeaturesConfig</a></td>
      <td>Features describe individual Talos features that can be switched on or off.</td>
      <td></td>
    </tr>
    <tr>
      <td>`udev`</td>
      <td><a href="#udev">UdevConfig</a></td>
      <td>Configures the udev system.</td>
      <td></td>
    </tr>
    <tr>
      <td>`logging`</td>
      <td><a href="#logging">LoggingConfig</a></td>
      <td>Configures the logging system.</td>
      <td></td>
    </tr>
    <tr>
      <td>`kernel`</td>
      <td><a href="#kernel">KernelConfig</a></td>
      <td>Configures the kernel.</td>
      <td></td>
    </tr>
    <tr>
      <td>`seccompProfiles`</td>
      <td><a href="#seccompprofiles%5B%5D">MachineSeccompProfile</a></td>
      <td>Configures the seccomp profiles for the machine.</td>
      <td></td>
    </tr>
    <tr>
      <td>`baseRuntimeSpecOverrides`</td>
      <td>Unstructured</td>
      <td>Override (patch) settings in the default OCI runtime spec for CRI containers.<br /><br />It can be used to set some default container settings which are not configurable in Kubernetes,<br />for example default ulimits.<br />Note: this change applies to all newly created containers, and it requires a reboot to take effect.</td>
      <td></td>
    </tr>
    <tr>
      <td>`nodeLabels`</td>
      <td>map[string]string</td>
      <td>Configures the node labels for the machine.<br /><br />Note: In the default Kubernetes configuration, worker nodes are restricted to set<br />labels with some prefixes (see [NodeRestriction](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction) admission plugin).</td>
      <td></td>
    </tr>
    <tr>
      <td>`nodeAnnotations`</td>
      <td>map[string]string</td>
      <td>Configures the node annotations for the machine.</td>
      <td></td>
    </tr>
    <tr>
      <td>`nodeTaints`</td>
      <td>map[string]string</td>
      <td>Configures the node taints for the machine. Effect is optional.<br /><br />Note: In the default Kubernetes configuration, worker nodes are not allowed to<br />modify the taints (see [NodeRestriction](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction) admission plugin).</td>
      <td></td>
    </tr>
  </tbody>
</table>

### controlPlane

MachineControlPlaneConfig machine specific configuration options.

```yaml
machine:
    controlPlane:
        # Controller manager machine specific configuration options.
        controllerManager:
            disabled: false # Disable kube-controller-manager on the node.
        # Scheduler machine specific configuration options.
        scheduler:
            disabled: true # Disable kube-scheduler on the node.
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`controllerManager`</td>
      <td><a href="#controllermanager">MachineControllerManagerConfig</a></td>
      <td>Controller manager machine specific configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`scheduler`</td>
      <td><a href="#scheduler">MachineSchedulerConfig</a></td>
      <td>Scheduler machine specific configuration options.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### controllerManager

MachineControllerManagerConfig represents the machine specific ControllerManager config values.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`disabled`</td>
      <td>bool</td>
      <td>Disable kube-controller-manager on the node.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### scheduler

MachineSchedulerConfig represents the machine specific Scheduler config values.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`disabled`</td>
      <td>bool</td>
      <td>Disable kube-scheduler on the node.</td>
      <td></td>
    </tr>
  </tbody>
</table>

### kubelet

KubeletConfig represents the kubelet config values.

```yaml
machine:
    kubelet:
        image: ghcr.io/siderolabs/kubelet:v1.35.0 # The `image` field is an optional reference to an alternative kubelet image.
        # The `extraArgs` field is used to provide additional flags to the kubelet.
        extraArgs:
            feature-gates: ServerSideApply=true

        # # The `ClusterDNS` field is an optional reference to an alternative kubelet clusterDNS ip list.
        # clusterDNS:
        #     - 10.96.0.10
        #     - 169.254.2.53

        # # The `extraMounts` field is used to add additional mounts to the kubelet container.
        # extraMounts:
        #     - destination: /var/lib/example # Destination is the absolute path where the mount will be placed in the container.
        #       type: bind # Type specifies the mount kind.
        #       source: /var/lib/example # Source specifies the source path of the mount.
        #       # Options are fstab style mount options.
        #       options:
        #         - bind
        #         - rshared
        #         - rw

        # # The `extraConfig` field is used to provide kubelet configuration overrides.
        # extraConfig:
        #     serverTLSBootstrap: true

        # # The `KubeletCredentialProviderConfig` field is used to provide kubelet credential configuration.
        # credentialProviderConfig:
        #     apiVersion: kubelet.config.k8s.io/v1
        #     kind: CredentialProviderConfig
        #     providers:
        #         - apiVersion: credentialprovider.kubelet.k8s.io/v1
        #           defaultCacheDuration: 12h
        #           matchImages:
        #             - '*.dkr.ecr.*.amazonaws.com'
        #             - '*.dkr.ecr.*.amazonaws.com.cn'
        #             - '*.dkr.ecr-fips.*.amazonaws.com'
        #             - '*.dkr.ecr.us-iso-east-1.c2s.ic.gov'
        #             - '*.dkr.ecr.us-isob-east-1.sc2s.sgov.gov'
        #           name: ecr-credential-provider

        # # The `nodeIP` field is used to configure `--node-ip` flag for the kubelet.
        # nodeIP:
        #     # The `validSubnets` field configures the networks to pick kubelet node IP from.
        #     validSubnets:
        #         - 10.0.0.0/8
        #         - '!10.0.0.3/32'
        #         - fdc7::/16
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`image`</td>
      <td>string</td>
      <td>The `image` field is an optional reference to an alternative kubelet image.</td>
      <td></td>
    </tr>
    <tr>
      <td>`clusterDNS`</td>
      <td>[]string</td>
      <td>The `ClusterDNS` field is an optional reference to an alternative kubelet clusterDNS ip list.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraArgs`</td>
      <td>map[string]string</td>
      <td>The `extraArgs` field is used to provide additional flags to the kubelet.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraMounts`</td>
      <td><a href="#extramounts%5B%5D">ExtraMount</a></td>
      <td>The `extraMounts` field is used to add additional mounts to the kubelet container.<br />Note that either `bind` or `rbind` are required in the `options`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraConfig`</td>
      <td>Unstructured</td>
      <td>The `extraConfig` field is used to provide kubelet configuration overrides.<br /><br />Some fields are not allowed to be overridden: authentication and authorization, cgroups<br />configuration, ports, etc.</td>
      <td></td>
    </tr>
    <tr>
      <td>`credentialProviderConfig`</td>
      <td>Unstructured</td>
      <td>The `KubeletCredentialProviderConfig` field is used to provide kubelet credential configuration.</td>
      <td></td>
    </tr>
    <tr>
      <td>`defaultRuntimeSeccompProfileEnabled`</td>
      <td>bool</td>
      <td>Enable container runtime default Seccomp profile.</td>
      <td>`true`<br />`yes`<br />`false`<br />`no`<br /></td>
    </tr>
    <tr>
      <td>`registerWithFQDN`</td>
      <td>bool</td>
      <td>The `registerWithFQDN` field is used to force kubelet to use the node FQDN for registration.<br />This is required in clouds like AWS.</td>
      <td>`true`<br />`yes`<br />`false`<br />`no`<br /></td>
    </tr>
    <tr>
      <td>`nodeIP`</td>
      <td><a href="#nodeip">KubeletNodeIPConfig</a></td>
      <td>The `nodeIP` field is used to configure `--node-ip` flag for the kubelet.<br />This is used when a node has multiple addresses to choose from.</td>
      <td></td>
    </tr>
    <tr>
      <td>`skipNodeRegistration`</td>
      <td>bool</td>
      <td>The `skipNodeRegistration` is used to run the kubelet without registering with the apiserver.<br />This runs kubelet as standalone and only runs static pods.</td>
      <td>`true`<br />`yes`<br />`false`<br />`no`<br /></td>
    </tr>
    <tr>
      <td>`disableManifestsDirectory`</td>
      <td>bool</td>
      <td>The `disableManifestsDirectory` field configures the kubelet to get static pod manifests from the /etc/kubernetes/manifests directory.<br />It's recommended to configure static pods with the "pods" key instead.</td>
      <td>`true`<br />`yes`<br />`false`<br />`no`<br /></td>
    </tr>
  </tbody>
</table>

#### extraMounts[]

ExtraMount wraps OCI Mount specification.

```yaml
machine:
    kubelet:
        extraMounts:
            - destination: /var/lib/example # Destination is the absolute path where the mount will be placed in the container.
              type: bind # Type specifies the mount kind.
              source: /var/lib/example # Source specifies the source path of the mount.
              # Options are fstab style mount options.
              options:
                - bind
                - rshared
                - rw
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`destination`</td>
      <td>string</td>
      <td>Destination is the absolute path where the mount will be placed in the container.</td>
      <td></td>
    </tr>
    <tr>
      <td>`type`</td>
      <td>string</td>
      <td>Type specifies the mount kind.</td>
      <td></td>
    </tr>
    <tr>
      <td>`source`</td>
      <td>string</td>
      <td>Source specifies the source path of the mount.</td>
      <td></td>
    </tr>
    <tr>
      <td>`options`</td>
      <td>[]string</td>
      <td>Options are fstab style mount options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`uidMappings`</td>
      <td><a href="#uidmappings%5B%5D">LinuxIDMapping</a></td>
      <td>UID/GID mappings used for changing file owners w/o calling chown, fs should support it.<br /><br />Every mount point could have its own mapping.</td>
      <td></td>
    </tr>
    <tr>
      <td>`gidMappings`</td>
      <td><a href="#gidmappings%5B%5D">LinuxIDMapping</a></td>
      <td>UID/GID mappings used for changing file owners w/o calling chown, fs should support it.<br /><br />Every mount point could have its own mapping.</td>
      <td></td>
    </tr>
  </tbody>
</table>

##### uidMappings[]

LinuxIDMapping represents the Linux ID mapping.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`containerID`</td>
      <td>uint32</td>
      <td>ContainerID is the starting UID/GID in the container.</td>
      <td></td>
    </tr>
    <tr>
      <td>`hostID`</td>
      <td>uint32</td>
      <td>HostID is the starting UID/GID on the host to be mapped to 'ContainerID'.</td>
      <td></td>
    </tr>
    <tr>
      <td>`size`</td>
      <td>uint32</td>
      <td>Size is the number of IDs to be mapped.</td>
      <td></td>
    </tr>
  </tbody>
</table>

##### gidMappings[]

LinuxIDMapping represents the Linux ID mapping.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`containerID`</td>
      <td>uint32</td>
      <td>ContainerID is the starting UID/GID in the container.</td>
      <td></td>
    </tr>
    <tr>
      <td>`hostID`</td>
      <td>uint32</td>
      <td>HostID is the starting UID/GID on the host to be mapped to 'ContainerID'.</td>
      <td></td>
    </tr>
    <tr>
      <td>`size`</td>
      <td>uint32</td>
      <td>Size is the number of IDs to be mapped.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### nodeIP

KubeletNodeIPConfig represents the kubelet node IP configuration.

```yaml
machine:
    kubelet:
        nodeIP:
            # The `validSubnets` field configures the networks to pick kubelet node IP from.
            validSubnets:
                - 10.0.0.0/8
                - '!10.0.0.3/32'
                - fdc7::/16
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`validSubnets`</td>
      <td>[]string</td>
      <td>The `validSubnets` field configures the networks to pick kubelet node IP from.<br />For dual stack configuration, there should be two subnets: one for IPv4, another for IPv6.<br />IPs can be excluded from the list by using negative match with `!`, e.g `!10.0.0.0/8`.<br />Negative subnet matches should be specified last to filter out IPs picked by positive matches.<br />If not specified, node IP is picked based on cluster podCIDRs: IPv4/IPv6 address or both.</td>
      <td></td>
    </tr>
  </tbody>
</table>

### network

NetworkConfig represents the machine's networking config values.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`kubespan`</td>
      <td><a href="#kubespan">NetworkKubeSpan</a></td>
      <td>Configures KubeSpan feature.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### kubespan

NetworkKubeSpan struct describes KubeSpan configuration.

```yaml
machine:
    network:
        kubespan:
            enabled: true # Enable the KubeSpan feature.
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`enabled`</td>
      <td>bool</td>
      <td>Enable the KubeSpan feature.<br />Cluster discovery should be enabled with .cluster.discovery.enabled for KubeSpan to be enabled.</td>
      <td></td>
    </tr>
    <tr>
      <td>`advertiseKubernetesNetworks`</td>
      <td>bool</td>
      <td>Control whether Kubernetes pod CIDRs are announced over KubeSpan from the node.<br />If disabled, CNI handles encapsulating pod-to-pod traffic into some node-to-node tunnel,<br />and KubeSpan handles the node-to-node traffic.<br />If enabled, KubeSpan will take over pod-to-pod traffic and send it over KubeSpan directly.<br />When enabled, KubeSpan should have a way to detect complete pod CIDRs of the node which<br />is not always the case with CNIs not relying on Kubernetes for IPAM.</td>
      <td></td>
    </tr>
    <tr>
      <td>`allowDownPeerBypass`</td>
      <td>bool</td>
      <td>Skip sending traffic via KubeSpan if the peer connection state is not up.<br />This provides configurable choice between connectivity and security: either traffic is always<br />forced to go via KubeSpan (even if Wireguard peer connection is not up), or traffic can go directly<br />to the peer if Wireguard connection can't be established.</td>
      <td></td>
    </tr>
    <tr>
      <td>`harvestExtraEndpoints`</td>
      <td>bool</td>
      <td>KubeSpan can collect and publish extra endpoints for each member of the cluster<br />based on Wireguard endpoint information for each peer.<br />This feature is disabled by default, don't enable it<br />with high number of peers (>50) in the KubeSpan network (performance issues).</td>
      <td></td>
    </tr>
    <tr>
      <td>`mtu`</td>
      <td>uint32</td>
      <td>KubeSpan link MTU size.<br />Default value is 1420.</td>
      <td></td>
    </tr>
    <tr>
      <td>`filters`</td>
      <td><a href="#filters">KubeSpanFilters</a></td>
      <td>KubeSpan advanced filtering of network addresses .<br /><br />Settings in this section are optional, and settings apply only to the node.</td>
      <td></td>
    </tr>
  </tbody>
</table>

##### filters

KubeSpanFilters struct describes KubeSpan advanced network addresses filtering.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`endpoints`</td>
      <td>[]string</td>
      <td>Filter node addresses which will be advertised as KubeSpan endpoints for peer-to-peer Wireguard connections.<br /><br />By default, all addresses are advertised, and KubeSpan cycles through all endpoints until it finds one that works.<br /><br />Default value: no filtering.</td>
      <td></td>
    </tr>
  </tbody>
</table>

### install

InstallConfig represents the installation options for preparing a node.

```yaml
machine:
    install:
        disk: /dev/sda # The disk used for installations.
        image: ghcr.io/siderolabs/installer:latest # Allows for supplying the image used to perform the installation.
        wipe: false # Indicates if the installation disk should be wiped at installation time.
        grubUseUKICmdline: true # Indicates if legacy GRUB bootloader should use kernel cmdline from the UKI instead of building it on the host.

        # # Look up disk using disk attributes like model, size, serial and others.
        # diskSelector:
        #     size: 4GB # Disk size.
        #     model: WDC* # Disk model `/sys/block/<dev>/device/model`.
        #     busPath: /pci0000:00/0000:00:17.0/ata1/host0/target0:0:0/0:0:0:0 # Disk bus path.
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`disk`</td>
      <td>string</td>
      <td>The disk used for installations.</td>
      <td></td>
    </tr>
    <tr>
      <td>`diskSelector`</td>
      <td><a href="#diskselector">InstallDiskSelector</a></td>
      <td>Look up disk using disk attributes like model, size, serial and others.<br />Always has priority over `disk`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`image`</td>
      <td>string</td>
      <td>Allows for supplying the image used to perform the installation.<br />Image reference for each Talos release can be found on<br />[GitHub releases page](https://github.com/siderolabs/talos/releases).</td>
      <td></td>
    </tr>
    <tr>
      <td>`wipe`</td>
      <td>bool</td>
      <td>Indicates if the installation disk should be wiped at installation time.<br />Defaults to `true`.</td>
      <td>`true`<br />`yes`<br />`false`<br />`no`<br /></td>
    </tr>
    <tr>
      <td>`legacyBIOSSupport`</td>
      <td>bool</td>
      <td>Indicates if MBR partition should be marked as bootable (active).<br />Should be enabled only for the systems with legacy BIOS that doesn't support GPT partitioning scheme.</td>
      <td></td>
    </tr>
    <tr>
      <td>`grubUseUKICmdline`</td>
      <td>bool</td>
      <td>Indicates if legacy GRUB bootloader should use kernel cmdline from the UKI instead of building it on the host.<br />This changes the way cmdline is managed with GRUB bootloader to be more consistent with UKI/systemd-boot.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### diskSelector

InstallDiskSelector represents a disk query parameters for the install disk lookup.

```yaml
machine:
    install:
        diskSelector:
            size: '>= 1TB' # Disk size.
            model: WDC* # Disk model `/sys/block/<dev>/device/model`.

            # # Disk bus path.
            # busPath: /pci0000:00/0000:00:17.0/ata1/host0/target0:0:0/0:0:0:0
            # busPath: /pci0000:00/*
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`size`</td>
      <td>InstallDiskSizeMatcher</td>
      <td>Disk size.</td>
      <td></td>
    </tr>
    <tr>
      <td>`name`</td>
      <td>string</td>
      <td>Disk name `/sys/block/<dev>/device/name`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`model`</td>
      <td>string</td>
      <td>Disk model `/sys/block/<dev>/device/model`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`serial`</td>
      <td>string</td>
      <td>Disk serial number `/sys/block/<dev>/serial`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`modalias`</td>
      <td>string</td>
      <td>Disk modalias `/sys/block/<dev>/device/modalias`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`uuid`</td>
      <td>string</td>
      <td>Disk UUID `/sys/block/<dev>/uuid`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`wwid`</td>
      <td>string</td>
      <td>Disk WWID `/sys/block/<dev>/wwid`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`type`</td>
      <td>InstallDiskType</td>
      <td>Disk Type.</td>
      <td>`ssd`<br />`hdd`<br />`nvme`<br />`sd`<br /></td>
    </tr>
    <tr>
      <td>`busPath`</td>
      <td>string</td>
      <td>Disk bus path.</td>
      <td></td>
    </tr>
  </tbody>
</table>

### files[]

MachineFile represents a file to write to disk.

```yaml
machine:
    files:
        - content: '...' # The contents of the file.
          permissions: 0o666 # The file's permissions in octal.
          path: /tmp/file.txt # The path of the file.
          op: append # The operation to use
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`content`</td>
      <td>string</td>
      <td>The contents of the file.</td>
      <td></td>
    </tr>
    <tr>
      <td>`permissions`</td>
      <td>FileMode</td>
      <td>The file's permissions in octal.</td>
      <td></td>
    </tr>
    <tr>
      <td>`path`</td>
      <td>string</td>
      <td>The path of the file.</td>
      <td></td>
    </tr>
    <tr>
      <td>`op`</td>
      <td>string</td>
      <td>The operation to use</td>
      <td>`create`<br />`append`<br />`overwrite`<br /></td>
    </tr>
  </tbody>
</table>

### features

FeaturesConfig describes individual Talos features that can be switched on or off.

```yaml
machine:
    features:
        diskQuotaSupport: true # Enable XFS project quota support for EPHEMERAL partition and user disks.

        # # Configure Talos API access from Kubernetes pods.
        # kubernetesTalosAPIAccess:
        #     enabled: true # Enable Talos API access from Kubernetes pods.
        #     # The list of Talos API roles which can be granted for access from Kubernetes pods.
        #     allowedRoles:
        #         - os:reader
        #     # The list of Kubernetes namespaces Talos API access is available from.
        #     allowedKubernetesNamespaces:
        #         - kube-system
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`kubernetesTalosAPIAccess`</td>
      <td><a href="#kubernetestalosapiaccess">KubernetesTalosAPIAccessConfig</a></td>
      <td>Configure Talos API access from Kubernetes pods.<br /><br />This feature is disabled if the feature config is not specified.</td>
      <td></td>
    </tr>
    <tr>
      <td>`diskQuotaSupport`</td>
      <td>bool</td>
      <td>Enable XFS project quota support for EPHEMERAL partition and user disks.<br />Also enables kubelet tracking of ephemeral disk usage in the kubelet via quota.</td>
      <td></td>
    </tr>
    <tr>
      <td>`kubePrism`</td>
      <td><a href="#kubeprism">KubePrism</a></td>
      <td>KubePrism - local proxy/load balancer on defined port that will distribute<br />requests to all API servers in the cluster.</td>
      <td></td>
    </tr>
    <tr>
      <td>`hostDNS`</td>
      <td><a href="#hostdns">HostDNSConfig</a></td>
      <td>Configures host DNS caching resolver.</td>
      <td></td>
    </tr>
    <tr>
      <td>`imageCache`</td>
      <td><a href="#imagecache">ImageCacheConfig</a></td>
      <td>Enable Image Cache feature.</td>
      <td></td>
    </tr>
    <tr>
      <td>`nodeAddressSortAlgorithm`</td>
      <td>string</td>
      <td>Select the node address sort algorithm.<br />The 'v1' algorithm sorts addresses by the address itself.<br />The 'v2' algorithm prefers more specific prefixes.<br />If unset, defaults to 'v1'.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### kubernetesTalosAPIAccess

KubernetesTalosAPIAccessConfig describes the configuration for the Talos API access from Kubernetes pods.

```yaml
machine:
    features:
        kubernetesTalosAPIAccess:
            enabled: true # Enable Talos API access from Kubernetes pods.
            # The list of Talos API roles which can be granted for access from Kubernetes pods.
            allowedRoles:
                - os:reader
            # The list of Kubernetes namespaces Talos API access is available from.
            allowedKubernetesNamespaces:
                - kube-system
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`enabled`</td>
      <td>bool</td>
      <td>Enable Talos API access from Kubernetes pods.</td>
      <td></td>
    </tr>
    <tr>
      <td>`allowedRoles`</td>
      <td>[]string</td>
      <td>The list of Talos API roles which can be granted for access from Kubernetes pods.<br /><br />Empty list means that no roles can be granted, so access is blocked.</td>
      <td></td>
    </tr>
    <tr>
      <td>`allowedKubernetesNamespaces`</td>
      <td>[]string</td>
      <td>The list of Kubernetes namespaces Talos API access is available from.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### kubePrism

KubePrism describes the configuration for the KubePrism load balancer.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`enabled`</td>
      <td>bool</td>
      <td>Enable KubePrism support - will start local load balancing proxy.</td>
      <td></td>
    </tr>
    <tr>
      <td>`port`</td>
      <td>int</td>
      <td>KubePrism port.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### hostDNS

HostDNSConfig describes the configuration for the host DNS resolver.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`enabled`</td>
      <td>bool</td>
      <td>Enable host DNS caching resolver.</td>
      <td></td>
    </tr>
    <tr>
      <td>`forwardKubeDNSToHost`</td>
      <td>bool</td>
      <td>Use the host DNS resolver as upstream for Kubernetes CoreDNS pods.<br /><br />When enabled, CoreDNS pods use host DNS server as the upstream DNS (instead of<br />using configured upstream DNS resolvers directly).</td>
      <td></td>
    </tr>
    <tr>
      <td>`resolveMemberNames`</td>
      <td>bool</td>
      <td>Resolve member hostnames using the host DNS resolver.<br /><br />When enabled, cluster member hostnames and node names are resolved using the host DNS resolver.<br />This requires service discovery to be enabled.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### imageCache

ImageCacheConfig describes the configuration for the Image Cache feature.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`localEnabled`</td>
      <td>bool</td>
      <td>Enable local image cache.</td>
      <td></td>
    </tr>
  </tbody>
</table>

### udev

UdevConfig describes how the udev system should be configured.

```yaml
machine:
    udev:
        # List of udev rules to apply to the udev system
        rules:
            - SUBSYSTEM=="drm", KERNEL=="renderD*", GROUP="44", MODE="0660"
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`rules`</td>
      <td>[]string</td>
      <td>List of udev rules to apply to the udev system</td>
      <td></td>
    </tr>
  </tbody>
</table>

### logging

LoggingConfig struct configures Talos logging.

```yaml
machine:
    logging:
        # Logging destination.
        destinations:
            - endpoint: tcp://1.2.3.4:12345 # Where to send logs. Supported protocols are "tcp" and "udp".
              format: json_lines # Logs format.
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`destinations`</td>
      <td><a href="#destinations%5B%5D">LoggingDestination</a></td>
      <td>Logging destination.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### destinations[]

LoggingDestination struct configures Talos logging destination.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`endpoint`</td>
      <td><a href="#endpoint">Endpoint</a></td>
      <td>Where to send logs. Supported protocols are "tcp" and "udp".</td>
      <td></td>
    </tr>
    <tr>
      <td>`format`</td>
      <td>string</td>
      <td>Logs format.</td>
      <td>`json_lines`<br /></td>
    </tr>
    <tr>
      <td>`extraTags`</td>
      <td>map[string]string</td>
      <td>Extra tags (key-value) pairs to attach to every log message sent.</td>
      <td></td>
    </tr>
  </tbody>
</table>

##### endpoint

Endpoint represents the endpoint URL parsed out of the machine config.

```yaml
machine:
    logging:
        destinations:
            - endpoint: https://1.2.3.4:6443
```

```yaml
machine:
    logging:
        destinations:
            - endpoint: https://cluster1.internal:6443
```

```yaml
machine:
    logging:
        destinations:
            - endpoint: udp://127.0.0.1:12345
```

```yaml
machine:
    logging:
        destinations:
            - endpoint: tcp://1.2.3.4:12345
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>

### kernel

KernelConfig struct configures Talos Linux kernel.

```yaml
machine:
    kernel:
        # Kernel modules to load.
        modules:
            - name: btrfs # Module name.
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`modules`</td>
      <td><a href="#modules%5B%5D">KernelModuleConfig</a></td>
      <td>Kernel modules to load.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### modules[]

KernelModuleConfig struct configures Linux kernel modules to load.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`name`</td>
      <td>string</td>
      <td>Module name.</td>
      <td></td>
    </tr>
    <tr>
      <td>`parameters`</td>
      <td>[]string</td>
      <td>Module parameters, changes applied after reboot.</td>
      <td></td>
    </tr>
  </tbody>
</table>

### seccompProfiles[]

MachineSeccompProfile defines seccomp profiles for the machine.

```yaml
machine:
    seccompProfiles:
        - name: audit.json # The `name` field is used to provide the file name of the seccomp profile.
          # The `value` field is used to provide the seccomp profile.
          value:
            defaultAction: SCMP_ACT_LOG
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`name`</td>
      <td>string</td>
      <td>The `name` field is used to provide the file name of the seccomp profile.</td>
      <td></td>
    </tr>
    <tr>
      <td>`value`</td>
      <td>Unstructured</td>
      <td>The `value` field is used to provide the seccomp profile.</td>
      <td></td>
    </tr>
  </tbody>
</table>

## cluster

ClusterConfig represents the cluster-wide config values.

```yaml
cluster:
    # ControlPlaneConfig represents the control plane configuration options.
    controlPlane:
        endpoint: https://1.2.3.4 # Endpoint is the canonical controlplane endpoint, which can be an IP address or a DNS hostname.
        localAPIServerPort: 443 # The port that the API server listens on internally.
    clusterName: talos.local
    # ClusterNetworkConfig represents kube networking configuration options.
    network:
        # The CNI used.
        cni:
            name: flannel # Name of CNI to use.
        dnsDomain: cluster.local # The domain used by Kubernetes DNS.
        # The pod subnet CIDR.
        podSubnets:
            - 10.244.0.0/16
        # The service subnet CIDR.
        serviceSubnets:
            - 10.96.0.0/12
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`id`</td>
      <td>string</td>
      <td>Globally unique identifier for this cluster (base64 encoded random 32 bytes).</td>
      <td></td>
    </tr>
    <tr>
      <td>`secret`</td>
      <td>string</td>
      <td>Shared secret of cluster (base64 encoded random 32 bytes).<br />This secret is shared among cluster members but should never be sent over the network.</td>
      <td></td>
    </tr>
    <tr>
      <td>`controlPlane`</td>
      <td><a href="#controlplane">ControlPlaneConfig</a></td>
      <td>Provides control plane specific configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`clusterName`</td>
      <td>string</td>
      <td>Configures the cluster's name.</td>
      <td></td>
    </tr>
    <tr>
      <td>`network`</td>
      <td><a href="#network">ClusterNetworkConfig</a></td>
      <td>Provides cluster specific network configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`token`</td>
      <td>string</td>
      <td>The [bootstrap token](https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens/) used to join the cluster.</td>
      <td></td>
    </tr>
    <tr>
      <td>`aescbcEncryptionSecret`</td>
      <td>string</td>
      <td>A key used for the [encryption of secret data at rest](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/).<br />Enables encryption with AESCBC.</td>
      <td></td>
    </tr>
    <tr>
      <td>`secretboxEncryptionSecret`</td>
      <td>string</td>
      <td>A key used for the [encryption of secret data at rest](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/).<br />Enables encryption with secretbox.<br />Secretbox has precedence over AESCBC.</td>
      <td></td>
    </tr>
    <tr>
      <td>`ca`</td>
      <td>PEMEncodedCertificateAndKey</td>
      <td>The base64 encoded root certificate authority used by Kubernetes.</td>
      <td></td>
    </tr>
    <tr>
      <td>`acceptedCAs`</td>
      <td>[]PEMEncodedCertificate</td>
      <td>The list of base64 encoded accepted certificate authorities used by Kubernetes.</td>
      <td></td>
    </tr>
    <tr>
      <td>`aggregatorCA`</td>
      <td>PEMEncodedCertificateAndKey</td>
      <td>The base64 encoded aggregator certificate authority used by Kubernetes for front-proxy certificate generation.<br /><br />This CA can be self-signed.</td>
      <td></td>
    </tr>
    <tr>
      <td>`serviceAccount`</td>
      <td>PEMEncodedKey</td>
      <td>The base64 encoded private key for service account token generation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`apiServer`</td>
      <td><a href="#apiserver">APIServerConfig</a></td>
      <td>API server specific configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`controllerManager`</td>
      <td><a href="#controllermanager">ControllerManagerConfig</a></td>
      <td>Controller manager server specific configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`proxy`</td>
      <td><a href="#proxy">ProxyConfig</a></td>
      <td>Kube-proxy server-specific configuration options</td>
      <td></td>
    </tr>
    <tr>
      <td>`scheduler`</td>
      <td><a href="#scheduler">SchedulerConfig</a></td>
      <td>Scheduler server specific configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`discovery`</td>
      <td><a href="#discovery">ClusterDiscoveryConfig</a></td>
      <td>Configures cluster member discovery.</td>
      <td></td>
    </tr>
    <tr>
      <td>`etcd`</td>
      <td><a href="#etcd">EtcdConfig</a></td>
      <td>Etcd specific configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`coreDNS`</td>
      <td><a href="#coredns">CoreDNS</a></td>
      <td>Core DNS specific configuration options.</td>
      <td></td>
    </tr>
    <tr>
      <td>`externalCloudProvider`</td>
      <td><a href="#externalcloudprovider">ExternalCloudProviderConfig</a></td>
      <td>External cloud provider configuration.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraManifests`</td>
      <td>[]string</td>
      <td>A list of urls that point to additional manifests.<br />These will get automatically deployed as part of the bootstrap.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraManifestHeaders`</td>
      <td>map[string]string</td>
      <td>A map of key value pairs that will be added while fetching the extraManifests.</td>
      <td></td>
    </tr>
    <tr>
      <td>`inlineManifests`</td>
      <td><a href="#inlinemanifests%5B%5D">ClusterInlineManifest</a></td>
      <td>A list of inline Kubernetes manifests.<br />These will get automatically deployed as part of the bootstrap.</td>
      <td></td>
    </tr>
    <tr>
      <td>`adminKubeconfig`</td>
      <td><a href="#adminkubeconfig">AdminKubeconfigConfig</a></td>
      <td>Settings for admin kubeconfig generation.<br />Certificate lifetime can be configured.</td>
      <td></td>
    </tr>
    <tr>
      <td>`allowSchedulingOnControlPlanes`</td>
      <td>bool</td>
      <td>Allows running workload on control-plane nodes.</td>
      <td>`true`<br />`yes`<br />`false`<br />`no`<br /></td>
    </tr>
  </tbody>
</table>

### controlPlane

ControlPlaneConfig represents the control plane configuration options.

```yaml
cluster:
    controlPlane:
        endpoint: https://1.2.3.4 # Endpoint is the canonical controlplane endpoint, which can be an IP address or a DNS hostname.
        localAPIServerPort: 443 # The port that the API server listens on internally.
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`endpoint`</td>
      <td><a href="#endpoint">Endpoint</a></td>
      <td>Endpoint is the canonical controlplane endpoint, which can be an IP address or a DNS hostname.<br />It is single-valued, and may optionally include a port number.</td>
      <td></td>
    </tr>
    <tr>
      <td>`localAPIServerPort`</td>
      <td>int</td>
      <td>The port that the API server listens on internally.<br />This may be different than the port portion listed in the endpoint field above.<br />The default is `6443`.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### endpoint

Endpoint represents the endpoint URL parsed out of the machine config.

```yaml
cluster:
    controlPlane:
        endpoint: https://1.2.3.4:6443
```

```yaml
cluster:
    controlPlane:
        endpoint: https://cluster1.internal:6443
```

```yaml
cluster:
    controlPlane:
        endpoint: udp://127.0.0.1:12345
```

```yaml
cluster:
    controlPlane:
        endpoint: tcp://1.2.3.4:12345
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>

### network

ClusterNetworkConfig represents kube networking configuration options.

```yaml
cluster:
    network:
        # The CNI used.
        cni:
            name: flannel # Name of CNI to use.
        dnsDomain: cluster.local # The domain used by Kubernetes DNS.
        # The pod subnet CIDR.
        podSubnets:
            - 10.244.0.0/16
        # The service subnet CIDR.
        serviceSubnets:
            - 10.96.0.0/12
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`cni`</td>
      <td><a href="#cni">CNIConfig</a></td>
      <td>The CNI used.<br />Composed of "name" and "urls".<br />The "name" key supports the following options: "flannel", "custom", and "none".<br />"flannel" uses Talos-managed Flannel CNI, and that's the default option.<br />"custom" uses custom manifests that should be provided in "urls".<br />"none" indicates that Talos will not manage any CNI installation.</td>
      <td></td>
    </tr>
    <tr>
      <td>`dnsDomain`</td>
      <td>string</td>
      <td>The domain used by Kubernetes DNS.<br />The default is `cluster.local`</td>
      <td></td>
    </tr>
    <tr>
      <td>`podSubnets`</td>
      <td>[]string</td>
      <td>The pod subnet CIDR.</td>
      <td></td>
    </tr>
    <tr>
      <td>`serviceSubnets`</td>
      <td>[]string</td>
      <td>The service subnet CIDR.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### cni

CNIConfig represents the CNI configuration options.

```yaml
cluster:
    network:
        cni:
            name: custom # Name of CNI to use.
            # URLs containing manifests to apply for the CNI.
            urls:
                - https://docs.projectcalico.org/archive/v3.20/manifests/canal.yaml
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`name`</td>
      <td>string</td>
      <td>Name of CNI to use.</td>
      <td>`flannel`<br />`custom`<br />`none`<br /></td>
    </tr>
    <tr>
      <td>`urls`</td>
      <td>[]string</td>
      <td>URLs containing manifests to apply for the CNI.<br />Should be present for "custom", must be empty for "flannel" and "none".</td>
      <td></td>
    </tr>
    <tr>
      <td>`flannel`</td>
      <td><a href="#flannel">FlannelCNIConfig</a></td>
      <td>description:</td>
      <td><br />Flannel configuration options.<br /></td>
      <td></td>
    </tr>
  </tbody>
</table>

##### flannel

FlannelCNIConfig represents the Flannel CNI configuration options.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`extraArgs`</td>
      <td>[]string</td>
      <td>Extra arguments for 'flanneld'.</td>
      <td></td>
    </tr>
  </tbody>
</table>

### apiServer

APIServerConfig represents the kube apiserver configuration options.

```yaml
cluster:
    apiServer:
        image: registry.k8s.io/kube-apiserver:v1.35.0 # The container image used in the API server manifest.
        # Extra arguments to supply to the API server.
        extraArgs:
            feature-gates: ServerSideApply=true
            http2-max-streams-per-connection: "32"
        # Extra certificate subject alternative names for the API server's certificate.
        certSANs:
            - 1.2.3.4
            - 4.5.6.7

        # # Configure the API server admission plugins.
        # admissionControl:
        #     - name: PodSecurity # Name is the name of the admission controller.
        #       # Configuration is an embedded configuration object to be used as the plugin's
        #       configuration:
        #         apiVersion: pod-security.admission.config.k8s.io/v1alpha1
        #         defaults:
        #             audit: restricted
        #             audit-version: latest
        #             enforce: baseline
        #             enforce-version: latest
        #             warn: restricted
        #             warn-version: latest
        #         exemptions:
        #             namespaces:
        #                 - kube-system
        #             runtimeClasses: []
        #             usernames: []
        #         kind: PodSecurityConfiguration

        # # Configure the API server audit policy.
        # auditPolicy:
        #     apiVersion: audit.k8s.io/v1
        #     kind: Policy
        #     rules:
        #         - level: Metadata

        # # Configure the API server authorization config. Node and RBAC authorizers are always added irrespective of the configuration.
        # authorizationConfig:
        #     - type: Webhook # Type is the name of the authorizer. Allowed values are `Node`, `RBAC`, and `Webhook`.
        #       name: webhook # Name is used to describe the authorizer.
        #       # webhook is the configuration for the webhook authorizer.
        #       webhook:
        #         connectionInfo:
        #             type: InClusterConfig
        #         failurePolicy: Deny
        #         matchConditionSubjectAccessReviewVersion: v1
        #         matchConditions:
        #             - expression: has(request.resourceAttributes)
        #             - expression: '!(\''system:serviceaccounts:kube-system\'' in request.groups)'
        #         subjectAccessReviewVersion: v1
        #         timeout: 3s
        #     - type: Webhook # Type is the name of the authorizer. Allowed values are `Node`, `RBAC`, and `Webhook`.
        #       name: in-cluster-authorizer # Name is used to describe the authorizer.
        #       # webhook is the configuration for the webhook authorizer.
        #       webhook:
        #         connectionInfo:
        #             type: InClusterConfig
        #         failurePolicy: NoOpinion
        #         matchConditionSubjectAccessReviewVersion: v1
        #         subjectAccessReviewVersion: v1
        #         timeout: 3s
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`image`</td>
      <td>string</td>
      <td>The container image used in the API server manifest.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraArgs`</td>
      <td>map[string]string</td>
      <td>Extra arguments to supply to the API server.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraVolumes`</td>
      <td><a href="#extravolumes%5B%5D">VolumeMountConfig</a></td>
      <td>Extra volumes to mount to the API server static pod.</td>
      <td></td>
    </tr>
    <tr>
      <td>`env`</td>
      <td>Env</td>
      <td>The `env` field allows for the addition of environment variables for the control plane component.</td>
      <td></td>
    </tr>
    <tr>
      <td>`certSANs`</td>
      <td>[]string</td>
      <td>Extra certificate subject alternative names for the API server's certificate.</td>
      <td></td>
    </tr>
    <tr>
      <td>`admissionControl`</td>
      <td><a href="#admissioncontrol%5B%5D">AdmissionPluginConfig</a></td>
      <td>Configure the API server admission plugins.</td>
      <td></td>
    </tr>
    <tr>
      <td>`auditPolicy`</td>
      <td>Unstructured</td>
      <td>Configure the API server audit policy.</td>
      <td></td>
    </tr>
    <tr>
      <td>`resources`</td>
      <td><a href="#resources">ResourcesConfig</a></td>
      <td>Configure the API server resources.</td>
      <td></td>
    </tr>
    <tr>
      <td>`authorizationConfig`</td>
      <td><a href="#authorizationconfig%5B%5D">AuthorizationConfigAuthorizerConfig</a></td>
      <td>Configure the API server authorization config. Node and RBAC authorizers are always added irrespective of the configuration.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### extraVolumes[]

VolumeMountConfig struct describes extra volume mount for the static pods.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`hostPath`</td>
      <td>string</td>
      <td>Path on the host.</td>
      <td></td>
    </tr>
    <tr>
      <td>`mountPath`</td>
      <td>string</td>
      <td>Path in the container.</td>
      <td></td>
    </tr>
    <tr>
      <td>`readonly`</td>
      <td>bool</td>
      <td>Mount the volume read only.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### admissionControl[]

AdmissionPluginConfig represents the API server admission plugin configuration.

```yaml
cluster:
    apiServer:
        admissionControl:
            - name: PodSecurity # Name is the name of the admission controller.
              # Configuration is an embedded configuration object to be used as the plugin's
              configuration:
                apiVersion: pod-security.admission.config.k8s.io/v1alpha1
                defaults:
                    audit: restricted
                    audit-version: latest
                    enforce: baseline
                    enforce-version: latest
                    warn: restricted
                    warn-version: latest
                exemptions:
                    namespaces:
                        - kube-system
                    runtimeClasses: []
                    usernames: []
                kind: PodSecurityConfiguration
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`name`</td>
      <td>string</td>
      <td>Name is the name of the admission controller.<br />It must match the registered admission plugin name.</td>
      <td></td>
    </tr>
    <tr>
      <td>`configuration`</td>
      <td>Unstructured</td>
      <td>Configuration is an embedded configuration object to be used as the plugin's<br />configuration.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### resources

ResourcesConfig represents the pod resources.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`requests`</td>
      <td>Unstructured</td>
      <td>Requests configures the reserved cpu/memory resources.</td>
      <td></td>
    </tr>
    <tr>
      <td>`limits`</td>
      <td>Unstructured</td>
      <td>Limits configures the maximum cpu/memory resources a container can use.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### authorizationConfig[]

AuthorizationConfigAuthorizerConfig represents the API server authorization config authorizer configuration.

```yaml
cluster:
    apiServer:
        authorizationConfig:
            - type: Webhook # Type is the name of the authorizer. Allowed values are `Node`, `RBAC`, and `Webhook`.
              name: webhook # Name is used to describe the authorizer.
              # webhook is the configuration for the webhook authorizer.
              webhook:
                connectionInfo:
                    type: InClusterConfig
                failurePolicy: Deny
                matchConditionSubjectAccessReviewVersion: v1
                matchConditions:
                    - expression: has(request.resourceAttributes)
                    - expression: '!(\''system:serviceaccounts:kube-system\'' in request.groups)'
                subjectAccessReviewVersion: v1
                timeout: 3s
            - type: Webhook # Type is the name of the authorizer. Allowed values are `Node`, `RBAC`, and `Webhook`.
              name: in-cluster-authorizer # Name is used to describe the authorizer.
              # webhook is the configuration for the webhook authorizer.
              webhook:
                connectionInfo:
                    type: InClusterConfig
                failurePolicy: NoOpinion
                matchConditionSubjectAccessReviewVersion: v1
                subjectAccessReviewVersion: v1
                timeout: 3s
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`type`</td>
      <td>string</td>
      <td>Type is the name of the authorizer. Allowed values are `Node`, `RBAC`, and `Webhook`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`name`</td>
      <td>string</td>
      <td>Name is used to describe the authorizer.</td>
      <td></td>
    </tr>
    <tr>
      <td>`webhook`</td>
      <td>Unstructured</td>
      <td>webhook is the configuration for the webhook authorizer.</td>
      <td></td>
    </tr>
  </tbody>
</table>

### controllerManager

ControllerManagerConfig represents the kube controller manager configuration options.

```yaml
cluster:
    controllerManager:
        image: registry.k8s.io/kube-controller-manager:v1.35.0 # The container image used in the controller manager manifest.
        # Extra arguments to supply to the controller manager.
        extraArgs:
            feature-gates: ServerSideApply=true
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`image`</td>
      <td>string</td>
      <td>The container image used in the controller manager manifest.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraArgs`</td>
      <td>map[string]string</td>
      <td>Extra arguments to supply to the controller manager.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraVolumes`</td>
      <td><a href="#extravolumes%5B%5D">VolumeMountConfig</a></td>
      <td>Extra volumes to mount to the controller manager static pod.</td>
      <td></td>
    </tr>
    <tr>
      <td>`env`</td>
      <td>Env</td>
      <td>The `env` field allows for the addition of environment variables for the control plane component.</td>
      <td></td>
    </tr>
    <tr>
      <td>`resources`</td>
      <td><a href="#resources">ResourcesConfig</a></td>
      <td>Configure the controller manager resources.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### extraVolumes[]

VolumeMountConfig struct describes extra volume mount for the static pods.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`hostPath`</td>
      <td>string</td>
      <td>Path on the host.</td>
      <td></td>
    </tr>
    <tr>
      <td>`mountPath`</td>
      <td>string</td>
      <td>Path in the container.</td>
      <td></td>
    </tr>
    <tr>
      <td>`readonly`</td>
      <td>bool</td>
      <td>Mount the volume read only.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### resources

ResourcesConfig represents the pod resources.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`requests`</td>
      <td>Unstructured</td>
      <td>Requests configures the reserved cpu/memory resources.</td>
      <td></td>
    </tr>
    <tr>
      <td>`limits`</td>
      <td>Unstructured</td>
      <td>Limits configures the maximum cpu/memory resources a container can use.</td>
      <td></td>
    </tr>
  </tbody>
</table>

### proxy

ProxyConfig represents the kube proxy configuration options.

```yaml
cluster:
    proxy:
        image: registry.k8s.io/kube-proxy:v1.35.0 # The container image used in the kube-proxy manifest.
        mode: ipvs # proxy mode of kube-proxy.
        # Extra arguments to supply to kube-proxy.
        extraArgs:
            proxy-mode: iptables

        # # Disable kube-proxy deployment on cluster bootstrap.
        # disabled: false
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`disabled`</td>
      <td>bool</td>
      <td>Disable kube-proxy deployment on cluster bootstrap.</td>
      <td></td>
    </tr>
    <tr>
      <td>`image`</td>
      <td>string</td>
      <td>The container image used in the kube-proxy manifest.</td>
      <td></td>
    </tr>
    <tr>
      <td>`mode`</td>
      <td>string</td>
      <td>proxy mode of kube-proxy.<br />The default is 'iptables'.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraArgs`</td>
      <td>map[string]string</td>
      <td>Extra arguments to supply to kube-proxy.</td>
      <td></td>
    </tr>
  </tbody>
</table>

### scheduler

SchedulerConfig represents the kube scheduler configuration options.

```yaml
cluster:
    scheduler:
        image: registry.k8s.io/kube-scheduler:v1.35.0 # The container image used in the scheduler manifest.
        # Extra arguments to supply to the scheduler.
        extraArgs:
            feature-gates: AllBeta=true
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`image`</td>
      <td>string</td>
      <td>The container image used in the scheduler manifest.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraArgs`</td>
      <td>map[string]string</td>
      <td>Extra arguments to supply to the scheduler.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraVolumes`</td>
      <td><a href="#extravolumes%5B%5D">VolumeMountConfig</a></td>
      <td>Extra volumes to mount to the scheduler static pod.</td>
      <td></td>
    </tr>
    <tr>
      <td>`env`</td>
      <td>Env</td>
      <td>The `env` field allows for the addition of environment variables for the control plane component.</td>
      <td></td>
    </tr>
    <tr>
      <td>`resources`</td>
      <td><a href="#resources">ResourcesConfig</a></td>
      <td>Configure the scheduler resources.</td>
      <td></td>
    </tr>
    <tr>
      <td>`config`</td>
      <td>Unstructured</td>
      <td>Specify custom kube-scheduler configuration.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### extraVolumes[]

VolumeMountConfig struct describes extra volume mount for the static pods.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`hostPath`</td>
      <td>string</td>
      <td>Path on the host.</td>
      <td></td>
    </tr>
    <tr>
      <td>`mountPath`</td>
      <td>string</td>
      <td>Path in the container.</td>
      <td></td>
    </tr>
    <tr>
      <td>`readonly`</td>
      <td>bool</td>
      <td>Mount the volume read only.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### resources

ResourcesConfig represents the pod resources.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`requests`</td>
      <td>Unstructured</td>
      <td>Requests configures the reserved cpu/memory resources.</td>
      <td></td>
    </tr>
    <tr>
      <td>`limits`</td>
      <td>Unstructured</td>
      <td>Limits configures the maximum cpu/memory resources a container can use.</td>
      <td></td>
    </tr>
  </tbody>
</table>

### discovery

ClusterDiscoveryConfig struct configures cluster membership discovery.

```yaml
cluster:
    discovery:
        enabled: true # Enable the cluster membership discovery feature.
        # Configure registries used for cluster member discovery.
        registries:
            # Kubernetes registry uses Kubernetes API server to discover cluster members and stores additional information
            kubernetes: {}
            # Service registry is using an external service to push and pull information about cluster members.
            service:
                endpoint: https://discovery.talos.dev/ # External service endpoint.
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`enabled`</td>
      <td>bool</td>
      <td>Enable the cluster membership discovery feature.<br />Cluster discovery is based on individual registries which are configured under the registries field.</td>
      <td></td>
    </tr>
    <tr>
      <td>`registries`</td>
      <td><a href="#registries">DiscoveryRegistriesConfig</a></td>
      <td>Configure registries used for cluster member discovery.</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### registries

DiscoveryRegistriesConfig struct configures cluster membership discovery.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`kubernetes`</td>
      <td><a href="#kubernetes">RegistryKubernetesConfig</a></td>
      <td>Kubernetes registry uses Kubernetes API server to discover cluster members and stores additional information<br />as annotations on the Node resources.<br /><br />This feature is deprecated as it is not compatible with Kubernetes 1.32+.<br />See https://github.com/siderolabs/talos/issues/9980 for more information.</td>
      <td></td>
    </tr>
    <tr>
      <td>`service`</td>
      <td><a href="#service">RegistryServiceConfig</a></td>
      <td>Service registry is using an external service to push and pull information about cluster members.</td>
      <td></td>
    </tr>
  </tbody>
</table>

##### kubernetes

RegistryKubernetesConfig struct configures Kubernetes discovery registry.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`disabled`</td>
      <td>bool</td>
      <td>Disable Kubernetes discovery registry.</td>
      <td></td>
    </tr>
  </tbody>
</table>

##### service

RegistryServiceConfig struct configures Kubernetes discovery registry.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`disabled`</td>
      <td>bool</td>
      <td>Disable external service discovery registry.</td>
      <td></td>
    </tr>
    <tr>
      <td>`endpoint`</td>
      <td>string</td>
      <td>External service endpoint.</td>
      <td></td>
    </tr>
  </tbody>
</table>

### etcd

EtcdConfig represents the etcd configuration options.

```yaml
cluster:
    etcd:
        image: registry.k8s.io/etcd:v3.6.7 # The container image used to create the etcd service.
        # The `ca` is the root certificate authority of the PKI.
        ca:
            crt: LS0tIEVYQU1QTEUgQ0VSVElGSUNBVEUgLS0t
            key: LS0tIEVYQU1QTEUgS0VZIC0tLQ==
        # Extra arguments to supply to etcd.
        extraArgs:
            election-timeout: "5000"

        # # The `advertisedSubnets` field configures the networks to pick etcd advertised IP from.
        # advertisedSubnets:
        #     - 10.0.0.0/8
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`image`</td>
      <td>string</td>
      <td>The container image used to create the etcd service.</td>
      <td></td>
    </tr>
    <tr>
      <td>`ca`</td>
      <td>PEMEncodedCertificateAndKey</td>
      <td>The `ca` is the root certificate authority of the PKI.<br />It is composed of a base64 encoded `crt` and `key`.</td>
      <td></td>
    </tr>
    <tr>
      <td>`extraArgs`</td>
      <td>map[string]string</td>
      <td>Extra arguments to supply to etcd.<br />Note that the following args are not allowed:<br /><br />- `name`<br />- `data-dir`<br />- `initial-cluster-state`<br />- `listen-peer-urls`<br />- `listen-client-urls`<br />- `cert-file`<br />- `key-file`<br />- `trusted-ca-file`<br />- `peer-client-cert-auth`<br />- `peer-cert-file`<br />- `peer-trusted-ca-file`<br />- `peer-key-file`</td>
      <td></td>
    </tr>
    <tr>
      <td>`advertisedSubnets`</td>
      <td>[]string</td>
      <td>The `advertisedSubnets` field configures the networks to pick etcd advertised IP from.<br /><br />IPs can be excluded from the list by using negative match with `!`, e.g `!10.0.0.0/8`.<br />Negative subnet matches should be specified last to filter out IPs picked by positive matches.<br />If not specified, advertised IP is selected as the first routable address of the node.</td>
      <td></td>
    </tr>
    <tr>
      <td>`listenSubnets`</td>
      <td>[]string</td>
      <td>The `listenSubnets` field configures the networks for the etcd to listen for peer and client connections.<br /><br />If `listenSubnets` is not set, but `advertisedSubnets` is set, `listenSubnets` defaults to<br />`advertisedSubnets`.<br /><br />If neither `advertisedSubnets` nor `listenSubnets` is set, `listenSubnets` defaults to listen on all addresses.<br /><br />IPs can be excluded from the list by using negative match with `!`, e.g `!10.0.0.0/8`.<br />Negative subnet matches should be specified last to filter out IPs picked by positive matches.<br />If not specified, advertised IP is selected as the first routable address of the node.</td>
      <td></td>
    </tr>
  </tbody>
</table>

### coreDNS

CoreDNS represents the CoreDNS config values.

```yaml
cluster:
    coreDNS:
        image: registry.k8s.io/coredns/coredns:v1.13.2 # The `image` field is an override to the default coredns image.
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`disabled`</td>
      <td>bool</td>
      <td>Disable coredns deployment on cluster bootstrap.</td>
      <td></td>
    </tr>
    <tr>
      <td>`image`</td>
      <td>string</td>
      <td>The `image` field is an override to the default coredns image.</td>
      <td></td>
    </tr>
  </tbody>
</table>

### externalCloudProvider

ExternalCloudProviderConfig contains external cloud provider configuration.

```yaml
cluster:
    externalCloudProvider:
        enabled: true # Enable external cloud provider.
        # A list of urls that point to additional manifests for an external cloud provider.
        manifests:
            - https://raw.githubusercontent.com/kubernetes/cloud-provider-aws/v1.20.0-alpha.0/manifests/rbac.yaml
            - https://raw.githubusercontent.com/kubernetes/cloud-provider-aws/v1.20.0-alpha.0/manifests/aws-cloud-controller-manager-daemonset.yaml
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`enabled`</td>
      <td>bool</td>
      <td>Enable external cloud provider.</td>
      <td>`true`<br />`yes`<br />`false`<br />`no`<br /></td>
    </tr>
    <tr>
      <td>`manifests`</td>
      <td>[]string</td>
      <td>A list of urls that point to additional manifests for an external cloud provider.<br />These will get automatically deployed as part of the bootstrap.</td>
      <td></td>
    </tr>
  </tbody>
</table>

### inlineManifests[]

ClusterInlineManifest struct describes inline bootstrap manifests for the user.

```yaml
cluster:
    inlineManifests:
        - name: namespace-ci # Name of the manifest.
          contents: |- # Manifest contents as a string.
            apiVersion: v1
            kind: Namespace
            metadata:
            	name: ci
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`name`</td>
      <td>string</td>
      <td>Name of the manifest.<br />Name should be unique.</td>
      <td></td>
    </tr>
    <tr>
      <td>`contents`</td>
      <td>string</td>
      <td>Manifest contents as a string.</td>
      <td></td>
    </tr>
  </tbody>
</table>

### adminKubeconfig

AdminKubeconfigConfig contains admin kubeconfig settings.

```yaml
cluster:
    adminKubeconfig:
        certLifetime: 1h0m0s # Admin kubeconfig certificate lifetime (default is 1 year).
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Value(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`certLifetime`</td>
      <td>Duration</td>
      <td>Admin kubeconfig certificate lifetime (default is 1 year).<br />Field format accepts any Go time.Duration format ('1h' for one hour, '10m' for ten minutes).</td>
      <td></td>
    </tr>
  </tbody>
</table>
